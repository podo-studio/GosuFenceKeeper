<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì–‘ì¹˜ê¸° ì†Œë…„: ì²œë¼ì§€ë§</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jua&family=Nanum+Myeongjo&display=swap" rel="stylesheet">
    <style>
        .font-nanum { font-family: 'Nanum Myeongjo', serif; }
        .font-jua { font-family: 'Jua', sans-serif; }
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none;
            overflow: hidden;
            background-color: #111827; /* bg-gray-900 */
        }
        canvas {
            cursor: pointer;
            display: block;
            border-radius: 0.5rem;
            transition: background-color 1s ease-in-out;
        }
        .hud-item {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            user-select: none; /* Prevent text selection on buttons */
        }
        .hud-item:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .modal {
            background-color: rgba(0, 0, 0, 0.7);
        }
        .modal-content {
            background-color: #f0f0f0;
            color: #333;
        }
        .joystick {
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            position: absolute;
            bottom: 30px;
            left: 30px;
        }
        .joystick-handle {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 30px;
            left: 30px;
        }
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
        #game-log {
            font-family: monospace;
            line-height: 1.2;
        }
        #introModal {
            display: flex;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: #111827; /* bg-gray-900 */
            justify-content: center;
            align-items: center;
        }
        /* ë§¤ë‰´ì–¼ ìŠ¤íƒ€ì¼ */
        #manual-content h2 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #ccc;
            padding-bottom: 0.25rem;
        }
        #manual-content h3 {
            font-size: 1.25rem;
            font-weight: bold;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        #manual-content p, #manual-content ul {
            margin-bottom: 1rem;
        }
        #manual-content ul {
            list-style-position: inside;
        }
        #manual-content li {
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body class="w-screen h-screen flex items-center justify-center p-2">

    <!-- Main Menu Screen -->
    <div id="introModal">
        <div class="flex flex-col justify-center items-center h-screen text-center p-4 w-full">
            <div class="flex-grow flex flex-col justify-center items-center">
                <h1 class="text-6xl font-bold text-gray-200 mb-4 font-nanum" style="text-shadow: 2px 2px 4px #000;">
                    ì–‘ì¹˜ê¸° ì†Œë…„: ì€ë‘”ê³ ìˆ˜
                </h1>
				<p class="text-xs text-gray-500 mt-4 font-jua">
                    Fencekeeper.v.1.1
                </p>
				<p class="text-xs text-gray-500 mt-4 font-jua">
                    GosuFencekeeper.v.1.1
                </p>
                <button id="startButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full text-2xl shadow-lg transform hover:scale-105 transition-transform duration-300 mt-12">
                    ê²Œì„ ì‹œì‘
                </button>
            </div>
            <div class="pb-8">
                <div id="logo-container" class="mb-2 w-24 h-24 mx-auto"></div>
                <h2 class="text-2xl font-bold text-purple-300 font-jua" style="text-shadow: 1px 1px 2px #000;">
                    í¬ë„ ìŠ¤íŠœë””ì˜¤
                </h2>
                <p class="text-sm text-gray-400 font-jua">
                    ì„¸ìƒì—ì„œ ê°€ì¥ ë‹¬ì½¤í•œ ê²Œì„
                </p>
                <a href="https://podo-studio.github.io/home/" target="_blank" class="text-sm text-blue-400 hover:text-blue-300 underline font-jua mt-2 inline-block">
                    í™ˆí˜ì´ì§€ ë°”ë¡œê°€ê¸°
                </a>
                <p class="text-xs text-gray-500 mt-4 font-jua">
                    Â© 2025 Podo Studio. All Rights Reserved.
                </p>
            </div>
        </div>
    </div>

    <!-- Game Content -->
    <div id="game-container" class="relative w-full h-full max-w-screen-lg max-h-screen-md aspect-video" style="display: none;">
        <canvas id="gameCanvas"></canvas>

        <!-- HUD -->
        <div class="absolute top-2 left-2 right-2 flex justify-between items-start gap-2">
            <div class="flex flex-col sm:flex-row gap-2">
                <div id="time-hud" class="hud-item"><span>ğŸ•’</span> <span id="time-display">ì˜¤ì „ 06:00</span></div>
                <div id="day-hud" class="hud-item"><span>ğŸ—“ï¸</span> <span id="day-display">Day 1</span></div>
                <div id="season-hud" class="hud-item"><span></span> <span id="season-display"></span></div>
                <div id="merchant-hud" class="hud-item hidden"><span>ğŸ‘³</span> <span id="merchant-display"></span></div>
                <button id="manual-open-button" class="hud-item font-bold text-lg w-10 h-10 flex items-center justify-center p-0">?</button>
            </div>
            <div class="flex flex-col sm:flex-row gap-2 items-end flex-wrap justify-end">
                <div id="gold-hud" class="hud-item"><span>ğŸ’°</span> <span id="gold-display">10</span></div>
                <div id="sheep-hud" class="hud-item"><span>ğŸ‘</span> <span id="sheep-display">5</span></div>
                <div id="hay-hud" class="hud-item"><span>ğŸŒ¾</span> <span id="hay-display">0</span></div>
                <div id="food-hud" class="hud-item"><span>ğŸ–</span> <span id="food-display">5</span></div>
                <div id="wolf-skin-hud" class="hud-item"><span>ğŸº</span> <span id="wolf-skin-display">0</span></div>
                <div id="wool-hud" class="hud-item"><span>ğŸ§¶</span> <span id="wool-display">0</span></div>
                <div id="fence-hud" class="hud-item"><span>ğŸ§±</span> <span id="fence-display">0</span></div>
            </div>
        </div>
        
        <div id="dog-status-ui" class="absolute bottom-2 left-1/2 -translate-x-1/2 flex gap-2"></div>

        <div class="absolute bottom-2 right-2 flex flex-col gap-2">
            <!-- NEW: Cheonlajimang Skill Button -->
            <button id="cheonlajimang-button" class="hud-item">ğŸ•¸ï¸ ì²œë¼ì§€ë§</button>
            <button id="cut-grass-button" class="hud-item">ğŸŒ¿ í’€ ë² ê¸°</button>
            <button id="build-fence-button" class="hud-item">ğŸ§± ìš¸íƒ€ë¦¬ ì§“ê¸°</button>
            <button id="feed-shepherd-button" class="hidden hud-item">ğŸ– ì–‘ì¹˜ê¸° ë°¥ì£¼ê¸°</button>
            <button id="hay-action-button" class="hidden hud-item"></button>
            <button id="gate-button" class="hidden hud-item"> ë¬¸ ë‹«ê¸°</button>
            <button id="market-button" class="hidden hud-item">ğŸ›’ ì‹œì¥</button>
            <button id="dog-command-all-button" class="hidden hud-item">ğŸ¾ ì „ì²´ ëª…ë ¹</button>
        </div>

        <div id="joystick" class="joystick hidden">
            <div id="joystick-handle" class="joystick-handle"></div>
        </div>

        <div id="game-log" class="absolute bottom-2 left-2 w-1/4 max-w-xs h-1/4 bg-black bg-opacity-50 text-white p-2 rounded-lg overflow-y-auto text-xs">
            <p class="font-bold mb-1">ê²Œì„ ë¡œê·¸</p>
        </div>

        <div id="build-mode-indicator" class="hidden absolute top-1/4 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-70 text-white px-4 py-2 rounded-lg text-xl font-bold pointer-events-none">
            ê±´ì„¤ ëª¨ë“œ
        </div>
        <div id="cut-mode-indicator" class="hidden absolute top-1/4 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-70 text-white px-4 py-2 rounded-lg text-xl font-bold pointer-events-none">
            í’€ë² ê¸° ëª¨ë“œ
        </div>
    </div>

    <!-- Game Modals -->
    <div id="manual-modal" class="modal hidden fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="modal-content w-full max-w-2xl p-6 rounded-lg shadow-xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold">ê²Œì„ ë°©ë²•</h2>
                <button id="close-manual-button" class="text-3xl font-bold">&times;</button>
            </div>
            <div id="manual-content">
                <h2>1. ê²Œì„ ëª©í‘œ</h2>
                <p>ë‹¹ì‹ ì€ ì–‘ì¹˜ê¸° ì†Œë…„ì…ë‹ˆë‹¤. ì–‘ë“¤ì„ ëŠ‘ëŒ€ì˜ ìœ„í˜‘ê³¼ êµ¶ì£¼ë¦¼ìœ¼ë¡œë¶€í„° ë³´í˜¸í•˜ê³ , ìì›ì„ ê´€ë¦¬í•˜ë©° ìµœëŒ€í•œ ì˜¤ë«ë™ì•ˆ ì‚´ì•„ë‚¨ëŠ” ê²ƒì´ ëª©í‘œì…ë‹ˆë‹¤.</p>
                
                <h2>2. ê¸°ë³¸ ì¡°ì‘</h2>
                <h3>ì´ë™:</h3>
                <ul>
                    <li><strong>PC:</strong> `W`, `A`, `S`, `D` í‚¤ ë˜ëŠ” ë°©í–¥í‚¤(â†‘, â†, â†“, â†’)ë¥¼ ì‚¬ìš©í•´ ì–‘ì¹˜ê¸°ë¥¼ ì›€ì§ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li><strong>ëª¨ë°”ì¼:</strong> í™”ë©´ì— ë‚˜íƒ€ë‚˜ëŠ” ê°€ìƒ ì¡°ì´ìŠ¤í‹±ì„ ì´ìš©í•´ ì›€ì§ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                </ul>
                <h3>ìƒí˜¸ì‘ìš©:</h3>
                <ul>
                    <li><strong>PC:</strong> ë§ˆìš°ìŠ¤ë¡œ ì–‘, ê°œ, ë²„íŠ¼ ë“±ì„ í´ë¦­í•˜ì—¬ ìƒí˜¸ì‘ìš©í•©ë‹ˆë‹¤.</li>
                    <li><strong>ëª¨ë°”ì¼:</strong> í™”ë©´ì„ í„°ì¹˜í•˜ì—¬ ìƒí˜¸ì‘ìš©í•©ë‹ˆë‹¤.</li>
                </ul>

                <h2>3. ê²Œì„ ì‹œìŠ¤í…œ</h2>
                <h3>ì²œë¼ì§€ë§ (ğŸ•¸ï¸)</h3>
                <ul>
                    <li>ì–‘ì¹˜ê¸°ì˜ ê³ ìœ  ê¸°ìˆ ì…ë‹ˆë‹¤. ë²„íŠ¼ì„ ëˆŒëŸ¬ ëª¨ë“œë¥¼ í™œì„±í™”í•œ í›„, í™”ë©´ì„ ë“œë˜ê·¸í•˜ì—¬ ì„ ì„ ê·¸ë¦½ë‹ˆë‹¤.</li>
                    <li>ê·¸ë¦° ì„ ì´ ìŠ¤ìŠ¤ë¡œ êµì°¨í•˜ì—¬ ê³ ë¦¬ë¥¼ ë§Œë“¤ë©´ 'ì²œë¼ì§€ë§'ì´ ë°œë™ë©ë‹ˆë‹¤.</li>
                    <li>ê·¸ë¬¼ ì•ˆì— ìˆëŠ” ëª¨ë“  ë™ë¬¼(ì–‘, ê°œ, ëŠ‘ëŒ€)ì€ í”¼í•´ë¥¼ ì…ê³  ì ì‹œ ê¸°ì ˆí•˜ë©°, ì–‘ì¹˜ê¸° ìª½ìœ¼ë¡œ ëŒë ¤ì˜µë‹ˆë‹¤.</li>
                    <li>í©ì–´ì§„ ì–‘ì„ ëª¨ìœ¼ê±°ë‚˜ ëŠ‘ëŒ€ë¥¼ ê³µê²©í•˜ëŠ” ë° ìœ ìš©í•©ë‹ˆë‹¤. ì‚¬ìš© í›„ì—ëŠ” ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ì´ ìˆìŠµë‹ˆë‹¤.</li>
                    <li><strong>ì¤‘ìš”:</strong> ì„ ì„ ê·¸ë¦¬ëŠ” ë„ì¤‘ ìš¸íƒ€ë¦¬ ê°™ì€ ì¥ì• ë¬¼ì— ë‹¿ìœ¼ë©´ ê¸°ìˆ  ì‹œì „ì´ ì·¨ì†Œë©ë‹ˆë‹¤.</li>
                </ul>
                <h3>ê³„ì ˆ</h3>
                <ul>
                    <li>ê²Œì„ì€ 7ì¼ë§ˆë‹¤ ê³„ì ˆì´ ë°”ë€ë‹ˆë‹¤. (ë´„ â†’ ì—¬ë¦„ â†’ ê°€ì„ â†’ ê²¨ìš¸ â†’ ë´„)</li>
                    <li><strong>ë´„:</strong> ëª¨ë“  í’€ì´ ë‹¤ì‹œ ìë¼ë‚˜ê¸° ì‹œì‘í•©ë‹ˆë‹¤.</li>
                    <li><strong>ì—¬ë¦„:</strong> í’€ì´ ì™•ì„±í•˜ê²Œ ìëë‹ˆë‹¤.</li>
                    <li><strong>ê°€ì„:</strong> í’€ì´ ë” ì´ìƒ ìë¼ì§€ ì•ŠìŠµë‹ˆë‹¤.</li>
                    <li><strong>ê²¨ìš¸:</strong> ëª¨ë“  í’€ì´ ì‚¬ë¼ì§€ê³ , ìë¼ì§€ ì•ŠìŠµë‹ˆë‹¤. ì–‘ë“¤ì„ ìœ„í•´ ê±´ì´ˆë¥¼ ë¹„ì¶•í•´ì•¼ í•©ë‹ˆë‹¤.</li>
                </ul>
                <h3>ì‹œê°„ê³¼ í•˜ë£¨</h3>
                <ul>
                    <li>ê²Œì„ ì† ì‹œê°„ì€ ìë™ìœ¼ë¡œ íë¥´ë©°, í™”ë©´ ìƒë‹¨ì˜ ì‹œê³„ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li>ì €ë… 6ì‹œë¶€í„° ë‹¤ìŒ ë‚  ì•„ì¹¨ 6ì‹œê¹Œì§€ëŠ” ë°¤ì´ ë˜ë©°, ë°¤ì—ëŠ” ëŠ‘ëŒ€ê°€ ë‚˜íƒ€ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li>í•˜ë£¨ê°€ ì§€ë‚  ë•Œë§ˆë‹¤ ì–‘ì´ ì„±ì¥í•˜ê³ , íŠ¹ì • ì¡°ê±´ í•˜ì— ë²ˆì‹í•˜ê±°ë‚˜ í„¸ì´ ë‹¤ì‹œ ìëë‹ˆë‹¤.</li>
                </ul>
                <h3>ìì›</h3>
                <ul>
                    <li><strong>ğŸ’° ê³¨ë“œ:</strong> ì‹œì¥ì—ì„œ ì•„ì´í…œì„ ì‚¬ê±°ë‚˜ íŒ” ë•Œ ì‚¬ìš©í•˜ëŠ” ê¸°ë³¸ í™”íì…ë‹ˆë‹¤.</li>
                    <li><strong>ğŸ‘ ì–‘:</strong> ê°€ì¥ ì¤‘ìš”í•œ ìì›ì…ë‹ˆë‹¤. íŒë§¤í•˜ê±°ë‚˜, í„¸ì„ ê¹ê±°ë‚˜, ë„ì¶•í•˜ì—¬ ì‹ëŸ‰ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li><strong>ğŸŒ¾ ê±´ì´ˆ:</strong> ì–‘ë“¤ì˜ ì‚¬ë£Œì…ë‹ˆë‹¤. ì‹œì¥ì—ì„œ êµ¬ë§¤í•˜ì—¬ ëª©ì¥ì˜ ë¨¹ì´í†µì— ì±„ì›Œì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li><strong>ğŸ– ì‹ëŸ‰:</strong> ì–‘ì¹˜ê¸°ì™€ ê°œì˜ í—ˆê¸°ë¥¼ ì±„ìš°ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ì–‘ì„ ë„ì¶•í•˜ê±°ë‚˜ ì‹œì¥ì—ì„œ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li><strong>ğŸº ëŠ‘ëŒ€ ê°€ì£½:</strong> ëŠ‘ëŒ€ë¥¼ ì²˜ì¹˜í•˜ë©´ ì–»ì„ ìˆ˜ ìˆìœ¼ë©°, ì‹œì¥ì— íŒë§¤í•˜ì—¬ ê³¨ë“œë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li><strong>ğŸ§¶ ì–‘í„¸:</strong> ì„±ì¸ ì–‘ì˜ í„¸ì„ ê¹ì•„ ì–»ì„ ìˆ˜ ìˆìœ¼ë©°, ì‹œì¥ì— íŒë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li><strong>ğŸ§± ìš¸íƒ€ë¦¬:</strong> ì‹œì¥ì—ì„œ êµ¬ë§¤í•˜ì—¬ ì›í•˜ëŠ” ê³³ì— ì„¤ì¹˜í•  ìˆ˜ ìˆëŠ” ì¥ì• ë¬¼ì…ë‹ˆë‹¤.</li>
                </ul>

                <h2>4. ì£¼ìš” í™œë™</h2>
                <h3>ì–‘ ê´€ë¦¬</h3>
                <p>ì–‘ì„ í´ë¦­í•˜ë©´ ìƒí˜¸ì‘ìš© ë©”ë‰´ê°€ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.</p>
                <ul>
                    <li><strong>ëŒê³  ë‹¤ë‹ˆê¸°:</strong> ì–‘ì¹˜ê¸° ê°€ê¹Œì´ì—ì„œ ì–‘ì„ í´ë¦­í•˜ë©´ ì–‘ì„ ëŒê³  ë‹¤ë‹ˆê±°ë‚˜ ë†“ì•„ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•œ ë²ˆì— ì„±ì¸ ì–‘ 1ë§ˆë¦¬ ë˜ëŠ” ìƒˆë¼ ì–‘ 2ë§ˆë¦¬ê¹Œì§€ ëŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì„±ì¸ ì–‘ê³¼ ìƒˆë¼ ì–‘ ë™ì‹œì—ëŠ” ë¶ˆê°€)</li>
                    <li><strong>ì •ë³´ ë³´ê¸°:</strong> ì–‘ì¹˜ê¸°ì™€ ë©€ë¦¬ ë–¨ì–´ì§„ ì–‘ì„ í´ë¦­í•˜ë©´ ì •ë³´ ì°½ì´ ì—´ë¦½ë‹ˆë‹¤. ì •ë³´ ì°½ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ í–‰ë™ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:</li>
                    <ul>
                        <li><strong>ì´ë¦„ ë³€ê²½:</strong> ì–‘ì˜ ì´ë¦„ì„ ììœ ë¡­ê²Œ ë°”ê¿€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                        <li><strong>í„¸ ê¹ê¸°:</strong> ëŒê³  ë‹¤ë‹ˆëŠ” ì„±ì¸ ì–‘ì˜ í„¸ì„ ê¹ì•„ ì–‘í„¸ 1ê°œë¥¼ ì–»ìŠµë‹ˆë‹¤. í„¸ì„ ê¹ì€ ì–‘ì€ 5ì¼ ë™ì•ˆ í„¸ì„ ê¹ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</li>
                        <li><strong>íŒë§¤:</strong> ìƒì¸ ê·¼ì²˜ë¡œ ì–‘ì„ ë°ë ¤ê°€ë©´ ì–‘ì„ ì‹œì¥ ê°€ê²©ìœ¼ë¡œ íŒë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì„±ì¸ ì–‘: 5ê³¨ë“œ, ìƒˆë¼ ì–‘: 2ê³¨ë“œ)</li>
                        <li><strong>ë„ì¶•:</strong> ëŒê³  ë‹¤ë‹ˆëŠ” ì–‘ì„ ë„ì¶•í•˜ì—¬ ì‹ëŸ‰ì„ ì–»ìŠµë‹ˆë‹¤. (ì„±ì¸ ì–‘: ì‹ëŸ‰ 3, ìƒˆë¼ ì–‘: ì‹ëŸ‰ 1)</li>
                    </ul>
                </ul>
                <h3>ê°œ ê´€ë¦¬</h3>
                <ul>
                    <li><strong>ì •ë³´ í™•ì¸:</strong> ê°œë¥¼ ì§ì ‘ í´ë¦­í•˜ë©´ ì •ë³´ ì°½ì´ ì—´ë ¤ ì´ë¦„ì„ ë°”ê¾¸ê±°ë‚˜ ë°¥ì„ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li><strong>íƒœì„¸ ë³€ê²½:</strong> ê°œ ì •ë³´ ì°½ì—ì„œ 'ê²½ê³„' ë˜ëŠ” 'í‰í™”' íƒœì„¸ë¥¼ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 'ê²½ê³„' ëª¨ë“œì—ì„œëŠ” ëŠ‘ëŒ€ë¥¼ ë³´ë©´ ìë™ìœ¼ë¡œ ê³µê²©í•˜ì§€ë§Œ, 'í‰í™”' ëª¨ë“œì—ì„œëŠ” ëŠ‘ëŒ€ë¥¼ ë¬´ì‹œí•˜ê³  ëª…ë ¹ì„ ë”°ë¦…ë‹ˆë‹¤.</li>
                    <li><strong>ê°œë³„ ëª…ë ¹:</strong> í™”ë©´ í•˜ë‹¨ì˜ ê°œ ì•„ì´ì½˜ì„ í´ë¦­í•˜ì—¬ 'ë”°ë¼ì™€' ë˜ëŠ” 'ê¸°ë‹¤ë ¤' ëª…ë ¹ì„ ë‚´ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li><strong>ì´ë™ ëª…ë ¹:</strong> 'ê¸°ë‹¤ë ¤' ìƒíƒœì¸ ê°œì˜ ì •ë³´ ì°½ì—ì„œ 'ì´ë™í•˜ê¸°' ë²„íŠ¼ì„ ëˆ„ë¥¸ í›„, ë§µì˜ ì›í•˜ëŠ” ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ë©´ ê°œê°€ ê·¸ê³³ìœ¼ë¡œ ì´ë™í•˜ì—¬ ë‹¤ì‹œ 'ê¸°ë‹¤ë ¤' ìƒíƒœê°€ ë©ë‹ˆë‹¤.</li>
                    <li><strong>ì „ì²´ ëª…ë ¹:</strong> 'ì „ì²´ ëª…ë ¹' ë²„íŠ¼ìœ¼ë¡œ ëª¨ë“  ê°œì—ê²Œ ë™ì¼í•œ ëª…ë ¹ì„ ë‚´ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                </ul>
                <h3>í’€ ë² ê¸°</h3>
                <ul>
                    <li>'í’€ ë² ê¸°' ë²„íŠ¼ì„ ëˆŒëŸ¬ í’€ë² ê¸° ëª¨ë“œë¥¼ ì¼œê³  ëŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li>ëª¨ë“œê°€ ì¼œì§„ ìƒíƒœì—ì„œ ì–‘ì¹˜ê¸° ê·¼ì²˜ì— ìˆëŠ” ì™„ì „íˆ ìë€ í’€(3ë‹¨ê³„)ì„ í´ë¦­í•˜ë©´ í’€ì„ ë² ì–´ ê±´ì´ˆ 1ê°œë¥¼ íšë“í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li>ëœ ìë€ í’€ì€ ë²¨ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</li>
                </ul>
                <h3>ìš¸íƒ€ë¦¬ ê±´ì„¤</h3>
                <ul>
                    <li><strong>ê±´ì„¤ ëª¨ë“œ:</strong> 'ìš¸íƒ€ë¦¬ ì§“ê¸°' ë²„íŠ¼ì„ ëˆŒëŸ¬ ê±´ì„¤ ëª¨ë“œë¥¼ ì¼œê³  ëŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëª¨ë“œê°€ ì¼œì§€ë©´ ë²„íŠ¼ì´ íŒŒë€ìƒ‰ìœ¼ë¡œ ë³€í•˜ê³ , í™”ë©´ ì¤‘ì•™ì— "ê±´ì„¤ ëª¨ë“œ" í…ìŠ¤íŠ¸ê°€ í‘œì‹œë©ë‹ˆë‹¤.</li>
                    <li><strong>ì„¤ì¹˜/ì² ê±°:</strong> ê±´ì„¤ ëª¨ë“œì—ì„œëŠ” ì–‘ì¹˜ê¸° ê·¼ì²˜ì—ì„œë§Œ ìš¸íƒ€ë¦¬ë¥¼ ì„¤ì¹˜í•˜ê±°ë‚˜ ì² ê±°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                </ul>
                <h3>ìƒì¸ê³¼ ì‹œì¥</h3>
                <ul>
                    <li>ê²Œì„ ì‹œì‘ ì²«ë‚ ë¶€í„° ìƒì¸ì´ ëª¨ë‹¥ë¶ˆ ê·¼ì²˜ì— ë‚˜íƒ€ë‚©ë‹ˆë‹¤.</li>
                    <li>ìƒì¸ì€ 2ì¼ê°„ ë¨¸ë¬¼ê³  5ì¼ê°„ ì‚¬ë¼ì§€ëŠ” ì£¼ê¸°ë¥¼ ë°˜ë³µí•©ë‹ˆë‹¤. ìƒë‹¨ì˜ ìƒì¸ ì•„ì´ì½˜ìœ¼ë¡œ ë‚¨ì€ ê¸°ê°„ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li>ì–‘ì¹˜ê¸°ê°€ ìƒì¸ ê·¼ì²˜ë¡œ ê°€ë©´ 'ì‹œì¥' ë²„íŠ¼ì´ í™œì„±í™”ë©ë‹ˆë‹¤.</li>
                    <li>ì‹œì¥ì—ì„œ ì–‘, ê°œ, ê±´ì´ˆ, ì‹ëŸ‰, ìš¸íƒ€ë¦¬ ë“± ë‹¤ì–‘í•œ ë¬¼í’ˆì„ ì‚¬ê±°ë‚˜ íŒ” ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                </ul>
                <h3>ëª¨ë‹¥ë¶ˆ</h3>
                <ul>
                    <li>ìš¸íƒ€ë¦¬ ë°–ì— ëª¨ë‹¥ë¶ˆì´ ìˆìŠµë‹ˆë‹¤. ë°¤ì´ ë˜ë©´ ëª¨ë‹¥ë¶ˆì— ë¶ˆì´ ì¼œì§€ê³  ì£¼ë³€ì— ë…¸ë€ìƒ‰ ì•ˆì „ êµ¬ì—­ì´ í‘œì‹œë©ë‹ˆë‹¤.</li>
                    <li>ëŠ‘ëŒ€ëŠ” ëª¨ë‹¥ë¶ˆ ì•ˆì „ êµ¬ì—­ ì•ˆìœ¼ë¡œ ë“¤ì–´ì˜¬ ìˆ˜ ì—†ìœ¼ë©°, êµ¬ì—­ ì•ˆì— ìˆëŠ” ì–‘, ê°œ, ì–‘ì¹˜ê¸°ë¥¼ ê³µê²© ëª©í‘œë¡œ ì‚¼ì§€ ì•ŠìŠµë‹ˆë‹¤.</li>
                    <li>ëŠ‘ëŒ€ì—ê²Œ ì«“ê¸°ë”ë¼ë„ ì•ˆì „ êµ¬ì—­ìœ¼ë¡œ ë“¤ì–´ê°€ë©´ ëŠ‘ëŒ€ëŠ” ì¶”ê²©ì„ í¬ê¸°í•©ë‹ˆë‹¤.</li>
                </ul>


                <h2>5. ê²Œì„ ì˜¤ë²„</h2>
                <p>ì–‘ì¹˜ê¸°ì˜ ì²´ë ¥(HP)ì´ 0ì´ ë˜ë©´ ê²Œì„ì€ ì¢…ë£Œë©ë‹ˆë‹¤. êµ¶ì£¼ë¦¬ê±°ë‚˜ ëŠ‘ëŒ€ì˜ ê³µê²©ì„ ë°›ìœ¼ë©´ ì²´ë ¥ì´ ê°ì†Œí•˜ë‹ˆ í•­ìƒ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.</p>
            </div>
        </div>
    </div>

    <div id="market-modal" class="modal hidden absolute inset-0 flex items-center justify-center p-4">
        <div class="modal-content w-full max-w-lg p-6 rounded-lg shadow-xl overflow-y-auto max-h-full">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">ì‹œì¥</h2>
                <button onclick="game.ui.toggleMarketModal(false)" class="text-2xl font-bold">&times;</button>
            </div>
            <div id="market-message" class="text-center text-red-600 mb-4 hidden"></div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div id="market-buy-section">
                    <h3 class="font-bold mb-2 text-lg">êµ¬ë§¤</h3>
                </div>
                <div id="market-sell-section">
                    <h3 class="font-bold mb-2 text-lg">íŒë§¤</h3>
                </div>
            </div>
            <div class="mt-6 text-center">
                <button onclick="game.ui.toggleMarketModal(false)" class="bg-gray-500 text-white py-2 px-6 rounded-md hover:bg-gray-600">ë‹«ê¸°</button>
            </div>
        </div>
    </div>

    <div id="hay-modal" class="modal hidden absolute inset-0 flex items-center justify-center">
        <div class="modal-content w-11/12 max-w-sm p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 id="hay-modal-title" class="text-2xl font-bold">ê±´ì´ˆ ê´€ë¦¬</h2>
                <button onclick="game.ui.toggleHayModal(false)" class="text-2xl font-bold">&times;</button>
            </div>
            <div class="space-y-4">
                <p id="hay-modal-info"></p>
                <div class="flex items-center justify-center gap-2">
                    <button id="hay-quantity-minus" class="bg-gray-300 px-4 py-2 rounded-md font-bold">-</button>
                    <input id="hay-quantity-input" type="number" class="w-24 text-center text-lg font-bold border rounded-md" value="1" min="1">
                    <button id="hay-quantity-plus" class="bg-gray-300 px-4 py-2 rounded-md font-bold">+</button>
                </div>
                <input id="hay-quantity-slider" type="range" class="w-full" value="1" min="1">
                <button id="hay-confirm-button" class="w-full bg-green-500 text-white p-2 rounded-md hover:bg-green-600">í™•ì¸</button>
            </div>
        </div>
    </div>

    <div id="sheep-info-modal" class="modal hidden absolute inset-0 flex items-center justify-center">
        <div class="modal-content w-11/12 max-w-sm p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">ì–‘ ì •ë³´</h2>
                <button onclick="game.ui.toggleSheepInfoModal(false)" class="text-2xl font-bold">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <label for="sheep-name-input" class="block text-sm font-medium text-gray-700">ì´ë¦„</label>
                    <input id="sheep-name-input" type="text" class="w-full p-2 border rounded-md mt-1">
                </div>
                <div>
                    <p class="text-sm font-medium text-gray-700">ìƒíƒœ</p>
                    <p id="sheep-status-info" class="mt-1 p-2 bg-gray-100 rounded-md"></p>
                </div>
                <button id="sheep-release-button" class="hidden w-full bg-gray-500 text-white p-2 rounded-md hover:bg-gray-600">ë†“ì•„ì£¼ê¸°</button>
                <div class="grid grid-cols-2 gap-2">
                    <button id="sheep-shear-button" class="w-full bg-green-500 text-white p-2 rounded-md hover:bg-green-600">í„¸ ê¹ê¸°</button>
                    <button id="sheep-sell-button" class="w-full bg-yellow-500 text-white p-2 rounded-md hover:bg-yellow-600">íŒë§¤</button>
                </div>
                <button id="sheep-slaughter-button" class="w-full bg-red-500 text-white p-2 rounded-md hover:bg-red-600">ë„ì¶•</button>
                <button id="sheep-info-confirm" class="w-full bg-blue-500 text-white p-2 rounded-md hover:bg-blue-600">ì´ë¦„ ë³€ê²½</button>
            </div>
        </div>
    </div>

    <div id="dog-info-modal" class="modal hidden absolute inset-0 flex items-center justify-center">
        <div class="modal-content w-11/12 max-w-sm p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">ê°œ ì •ë³´</h2>
                <button onclick="game.ui.toggleDogInfoModal(false)" class="text-2xl font-bold">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <label for="dog-name-input" class="block text-sm font-medium text-gray-700">ì´ë¦„</label>
                    <input id="dog-name-input" type="text" class="w-full p-2 border rounded-md mt-1">
                </div>
                <div>
                    <p class="text-sm font-medium text-gray-700">íƒœì„¸</p>
                    <div id="dog-stance-info" class="grid grid-cols-2 gap-2 mt-1">
                        <button id="dog-stance-guard" class="w-full p-2 rounded-md">ê²½ê³„</button>
                        <button id="dog-stance-peace" class="w-full p-2 rounded-md">í‰í™”</button>
                    </div>
                </div>
                <div>
                    <p class="text-sm font-medium text-gray-700">ë°°ë¶€ë¦„</p>
                    <p id="dog-hunger-info" class="mt-1 p-2 bg-gray-100 rounded-md"></p>
                </div>
                <button id="dog-move-button" class="w-full bg-yellow-500 text-white p-2 rounded-md hover:bg-yellow-600">ì´ë™í•˜ê¸°</button>
                <button id="dog-feed-button" class="w-full bg-green-500 text-white p-2 rounded-md hover:bg-green-600">ìŒì‹ ë¨¹ê¸°</button>
                <button id="dog-info-confirm" class="w-full bg-blue-500 text-white p-2 rounded-md hover:bg-blue-600">í™•ì¸</button>
            </div>
        </div>
    </div>
    
    <div id="game-over-modal" class="modal hidden absolute inset-0 flex items-center justify-center">
        <div class="modal-content w-11/12 max-w-md p-6 rounded-lg shadow-xl text-center">
            <h2 class="text-3xl font-bold mb-4">ê²Œì„ ì˜¤ë²„</h2>
            <p id="game-over-stats" class="mb-6"></p>
            <button onclick="window.location.reload()" class="bg-blue-500 text-white p-3 rounded-md hover:bg-blue-600 text-lg">ë‹¤ì‹œ ì‹œì‘í•˜ê¸°</button>
        </div>
    </div>

    <div id="confirm-modal" class="modal hidden absolute inset-0 flex items-center justify-center p-4">
        <div class="modal-content w-11/12 max-w-sm p-6 rounded-lg shadow-xl text-center">
            <p id="confirm-message" class="text-lg font-semibold mb-6"></p>
            <div class="flex justify-center gap-4">
                <button id="confirm-yes-button" class="bg-green-500 text-white p-2 rounded-md hover:bg-green-600 flex-1">ì˜ˆ</button>
                <button id="confirm-no-button" class="bg-red-500 text-white p-2 rounded-md hover:bg-red-600 flex-1">ì•„ë‹ˆì˜¤</button>
            </div>
        </div>
    </div>

    <script>
        // --- ê²Œì„ ì„¤ì • ---
        const config = {
            TIME_SCALE: 100,
            DAY_DURATION: 12 * 60,
            SHEPHERD_SPEED: 2,
            SHEEP_SPEED: 1.5,
            DOG_SPEED: 2.5,
            WOLF_SPEED: 1.8,
            WOLF_SPAWN_TIME: 21 * 60,
            GRASS_TILE_SIZE: 20,
            GRASS_EATING_DELAY: 2000,
            FENCE_SIZE: 20, // ìš¸íƒ€ë¦¬ í¬ê¸°
            SEASON_LENGTH: 7, // ê³„ì ˆ ê¸¸ì´ (ì¼)
        };

        // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---
        const utils = {
            distance(p1, p2) {
                return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
            },
            isMobile() {
                return /Mobi|Android/i.test(navigator.userAgent);
            },
            // NEW: Cheonlajimang helper functions
            getLineIntersection(p1, p2, p3, p4) {
                const d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
                if (d === 0) return null;
                const t = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;
                const u = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;
                if (t > 0.01 && t < 0.99 && u > 0.01 && u < 0.99) {
                    return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
                }
                return null;
            },
            pointInPolygon(point, vs) {
                let x = point.x, y = point.y;
                let inside = false;
                for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                    let xi = vs[i].x, yi = vs[i].y;
                    let xj = vs[j].x, yj = vs[j].y;
                    let intersect = ((yi > y) != (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
        };
        
        // --- ê²Œì„ í´ë˜ìŠ¤ ---
        class Game {
            constructor(canvas) {
                this.idCounters = { dog: 0 };
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.entities = [];
                this.leaderSheep = null;
                this.merchant = null; // ìƒì¸ ì¸ìŠ¤í„´ìŠ¤
                this.seasons = ['Spring', 'Summer', 'Autumn', 'Winter'];
                this.seasonColors = {
                    Spring: { bg: '#6aa84f', grass: '#88c070' },
                    Summer: { bg: '#6aa84f', grass: '#88c070' },
                    Autumn: { bg: '#6aa84f', grass: '#d2b48c' },
                    Winter: { bg: '#6aa84f', grass: '#88c070' },
                };
                this.gameState = {
                    time: 6 * 60,
                    day: 1,
                    gold: 10,
                    hayStock: 0,
                    food: 5,
                    wolfSkin: 0,
                    wool: 0,
                    fences: 10,
                    isNight: false,
                    gameOver: false,
                    paused: false,
                    merchantState: 'present',
                    merchantTimer: 2,
                    season: 'Spring',
                };
                this.world = {
                    width: 2000,
                    height: 1500,
                    pasture: { 
                        x: 800, y: 550, width: 400, height: 400, 
                        gate: { x: 960, y: 950, width: 80, height: 20, isOpen: true },
                        trough: {
                            x: 820, y: 600, width: 200, height: 20,
                            troughTiles: [],
                            maxHayPerTile: 3,
                            numTroughTiles: 10,
                            hayAmount: 0
                        },
                        haystack: { x: 1150, y: 880, radius: 30 }
                    },
                    campfire: { x: 600, y: 750, radius: 30, safeRadius: 150 },
                    grassPatches: [],
                    fences: new Set(),
                };
                this.isBuildMode = false;
                this.isCutMode = false;
                this.isDogCommandMode = false; // ê°œ ì´ë™ ëª…ë ¹ ëª¨ë“œ
                this.dogToCommand = null; // ì´ë™ ëª…ë ¹ì„ ë°›ì„ ê°œ
                this.dogMoveMarkers = []; // ê°œ ì´ë™ ìœ„ì¹˜ í‘œì‹œ
                this.mouseGridPos = { x: 0, y: 0 };

                // NEW: Cheonlajimang skill state
                this.isSkillMode = false;
                this.skillPath = [];
                this.effects = [];

                const tileSize = config.GRASS_TILE_SIZE;
                const pastureGrid = {
                    left: Math.floor(this.world.pasture.x / tileSize),
                    top: Math.floor(this.world.pasture.y / tileSize),
                    right: Math.ceil((this.world.pasture.x + this.world.pasture.width) / tileSize),
                    bottom: Math.ceil((this.world.pasture.y + this.world.pasture.height) / tileSize)
                };
                const marginGrid = 10;
                const noGrassZoneGrid = {
                    left: pastureGrid.left - marginGrid,
                    top: pastureGrid.top - marginGrid,
                    right: pastureGrid.right + marginGrid,
                    bottom: pastureGrid.bottom + marginGrid
                };
                const noGrassZone = {
                    x: noGrassZoneGrid.left * tileSize,
                    y: noGrassZoneGrid.top * tileSize,
                    width: (noGrassZoneGrid.right - noGrassZoneGrid.left) * tileSize,
                    height: (noGrassZoneGrid.bottom - noGrassZoneGrid.top) * tileSize
                };
                this.initializeGrassPatches([
                    { x: 0, y: 0, width: this.world.width, height: noGrassZone.y },
                    { x: 0, y: noGrassZone.y + noGrassZone.height, width: this.world.width, height: this.world.height - (noGrassZone.y + noGrassZone.height) },
                    { x: 0, y: noGrassZone.y, width: noGrassZone.x, height: noGrassZone.height },
                    { x: noGrassZone.x + noGrassZone.width, y: noGrassZone.y, width: this.world.width - (noGrassZone.x + noGrassZone.width), height: noGrassZone.height }
                ]);

                this.removeGrassAroundCampfire();
                this.initializeTroughTiles();
                this.world.pasture.trough.hayAmount = this.calculateTroughHayAmount();

                this.camera = { x: 0, y: 0 };
                this.input = new InputHandler(this);
                this.ui = new UI(this);
                this.market = new Market(this);
                this.lastTime = 0;
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.logDisplay = document.getElementById('game-log');
                this._lastStartedDay = 0;
                this._lastEndedDay = 0;
            }

            removeGrassAroundCampfire() {
                const cf = this.world.campfire;
                const removalRadius = cf.radius + (3 * config.GRASS_TILE_SIZE);
                this.world.grassPatches.forEach(patch => {
                    for (let r = 0; r < patch.tiles.length; r++) {
                        for (let c = 0; c < patch.tiles[r].length; c++) {
                            const tile = patch.tiles[r][c];
                            const tileCenter = {
                                x: patch.x + (c + 0.5) * config.GRASS_TILE_SIZE,
                                y: patch.y + (r + 0.5) * config.GRASS_TILE_SIZE
                            };
                            if (utils.distance(tileCenter, cf) < removalRadius) {
                                tile.richness = 0;
                            }
                        }
                    }
                });
            }

            initializeGrassPatches(patches) {
                patches.forEach(p => {
                    if (p.width <= 0 || p.height <= 0) return;
                    const patch = { ...p, tiles: [] };
                    const cols = Math.floor(p.width / config.GRASS_TILE_SIZE);
                    const rows = Math.floor(p.height / config.GRASS_TILE_SIZE);
                    for (let r = 0; r < rows; r++) {
                        patch.tiles[r] = [];
                        for (let c = 0; c < cols; c++) {
                            const richness = (r + c) % 2 === 0 ? 1 : 0; // ê²©ì íŒ¨í„´
                            patch.tiles[r][c] = { richness: richness, maxRichness: 3, regrowthTimer: 0 };
                        }
                    }
                    this.world.grassPatches.push(patch);
                });
            }

            initializeTroughTiles() {
                const trough = this.world.pasture.trough;
                trough.troughTiles = [];
                for (let i = 0; i < trough.numTroughTiles; i++) {
                    trough.troughTiles.push({ richness: 0, maxRichness: trough.maxHayPerTile });
                }
            }
            calculateTroughHayAmount() {
                const trough = this.world.pasture.trough;
                return trough.troughTiles.reduce((sum, tile) => sum + tile.richness, 0);
            }
            calculateTroughMaxHay() {
                const trough = this.world.pasture.trough;
                return trough.numTroughTiles * trough.maxHayPerTile;
            }

            start() {
                this.shepherd = new Shepherd(this, this.world.pasture.x + 50, this.world.pasture.y + 50);
                this.entities.push(this.shepherd);
                this.entities.push(new Dog(this, this.shepherd.x - 30, this.shepherd.y));
                for (let i = 0; i < 5; i++) {
                    this.entities.push(new Sheep(this, this.world.pasture.x + 100 + Math.random() * 200, this.world.pasture.y + 100 + Math.random() * 200, true));
                }
                this.spawnMerchant();
                this.gameLoop(0);
            }

            gameLoop(timestamp) {
                if (this.gameState.gameOver) return;
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;
                if (!this.gameState.paused) this.update(deltaTime);
                this.draw();
                requestAnimationFrame(this.gameLoop.bind(this));
            }

            update(deltaTime) {
                this.updateTime(deltaTime);
                this.updateLeaderSheep();
                this.entities = this.entities.filter(e => !e.isDead);
                this.input.update();
                this.entities.forEach(e => e.update(deltaTime));
                this.spawnWolves();
                this.updateCamera();
                this.ui.update();
                this.checkGameOver();
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();
                this.ctx.translate(-this.camera.x, -this.camera.y);
                this.drawBackground();
                this.entities.sort((a, b) => a.y - b.y).forEach(e => e.draw(this.ctx));
                this.drawModePreview();
                this.drawDogMoveMarkers();
                // NEW: Draw skill path and effects
                this.drawSkillPath();
                this.drawEffects();
                this.ctx.restore();
            }

            // NEW: Draw Cheonlajimang skill path
            drawSkillPath() {
                if (!this.isSkillMode || this.skillPath.length < 1) return;
                this.ctx.beginPath();
                this.ctx.moveTo(this.shepherd.x, this.shepherd.y);
                this.ctx.lineTo(this.skillPath[0].x, this.skillPath[0].y);
                for (let i = 1; i < this.skillPath.length; i++) {
                    this.ctx.lineTo(this.skillPath[i].x, this.skillPath[i].y);
                }
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 5]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            // NEW: Draw skill effects
            drawEffects() {
                const now = Date.now();
                this.effects = this.effects.filter(effect => now < effect.endTime);
                this.effects.forEach(effect => {
                    const timeRatio = (effect.endTime - now) / effect.duration;
                    if (effect.type === 'polygon') {
                        this.ctx.beginPath();
                        this.ctx.moveTo(effect.polygon[0].x, effect.polygon[0].y);
                        for(let i = 1; i < effect.polygon.length; i++) {
                            this.ctx.lineTo(effect.polygon[i].x, effect.polygon[i].y);
                        }
                        this.ctx.closePath();
                        this.ctx.fillStyle = `rgba(135, 206, 235, ${timeRatio * 0.4})`;
                        this.ctx.fill();
                        this.ctx.strokeStyle = `rgba(70, 130, 180, ${timeRatio * 0.8})`;
                        this.ctx.lineWidth = 5;
                        this.ctx.stroke();
                    }
                });
            }

            drawDogMoveMarkers() {
                this.ctx.font = '24px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'bottom';
                for (let i = this.dogMoveMarkers.length - 1; i >= 0; i--) {
                    const marker = this.dogMoveMarkers[i];
                    this.ctx.globalAlpha = marker.timer / 120; // Fade out effect
                    this.ctx.fillText('ğŸš©', marker.x, marker.y);
                    marker.timer--;
                    if (marker.timer <= 0) {
                        this.dogMoveMarkers.splice(i, 1);
                    }
                }
                this.ctx.globalAlpha = 1.0;
            }
            
            drawBackground() {
                const seasonColor = this.seasonColors[this.gameState.season].bg;
                this.canvas.style.backgroundColor = seasonColor;
                this.ctx.fillStyle = this.gameState.isNight ? '#4a7c3a' : seasonColor;
                this.ctx.fillRect(0, 0, this.world.width, this.world.height);
                
                this.world.grassPatches.forEach(p => {
                    for (let r = 0; r < p.tiles.length; r++) {
                        for (let c = 0; c < p.tiles[r].length; c++) {
                            const tile = p.tiles[r][c];
                            if (tile.richness > 0) {
                                const alpha = tile.richness / tile.maxRichness * 0.7 + 0.3;
                                const baseGrassColor = this.seasonColors[this.gameState.season].grass;
                                this.ctx.fillStyle = this.gameState.isNight ? `rgba(56, 102, 65, ${alpha})` : `${baseGrassColor}${Math.floor(alpha * 255).toString(16)}`;
                                this.ctx.fillRect(p.x + c * config.GRASS_TILE_SIZE, p.y + r * config.GRASS_TILE_SIZE, config.GRASS_TILE_SIZE, config.GRASS_TILE_SIZE);
                                
                                const tileX = p.x + c * config.GRASS_TILE_SIZE;
                                const tileY = p.y + r * config.GRASS_TILE_SIZE;
                                const s = config.GRASS_TILE_SIZE;
                                this.ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                                this.ctx.lineWidth = 1;
                                this.ctx.strokeRect(tileX + 2, tileY + 2, s - 4, s - 4);
                                const _max = (tile.maxRichness ?? 3);
                                const _ratio = Math.max(0, Math.min(1, tile.richness / _max));
                                const _fillH = (s - 6) * _ratio;
                                this.ctx.fillStyle = '#6fcf6f';
                                this.ctx.fillRect(tileX + 3, tileY + (s - 3) - _fillH, s - 6, _fillH);
                            }
                        }
                    }
                });

                const p = this.world.pasture;
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 10;
                this.ctx.strokeRect(p.x, p.y, p.width, p.height);
                
                this.ctx.fillStyle = '#A0522D';
                this.ctx.fillRect(p.trough.x, p.trough.y, p.trough.width, p.trough.height);

                const troughTileWidth = p.trough.width / p.trough.numTroughTiles;
                const troughTileHeight = p.trough.height;
                p.trough.troughTiles.forEach((tile, index) => {
                    if (tile.richness > 0) {
                        const fillRatio = tile.richness / tile.maxRichness;
                        const hayFillHeight = troughTileHeight * fillRatio;
                        this.ctx.fillStyle = '#f0e68c';
                        this.ctx.fillRect(
                            p.trough.x + index * troughTileWidth,
                            p.trough.y + troughTileHeight - hayFillHeight,
                            troughTileWidth,
                            hayFillHeight
                        );
                    }
                    this.ctx.strokeStyle = '#8B4513';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(
                        p.trough.x + index * troughTileWidth,
                        p.trough.y,
                        troughTileWidth,
                        troughTileHeight
                    );
                });

                this.ctx.fillStyle = '#DAA520';
                this.ctx.beginPath();
                this.ctx.arc(p.haystack.x, p.haystack.y, p.haystack.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                const gate = p.gate;
                if (gate.isOpen) {
                    this.ctx.clearRect(gate.x, gate.y - 5, gate.width, gate.height);
                } else {
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(gate.x, gate.y - 5, gate.width, gate.height);
                }

                this.ctx.fillStyle = '#8B4513';
                this.ctx.strokeStyle = '#5a2d0c';
                this.ctx.lineWidth = 2;
                const fenceSize = config.FENCE_SIZE;
                for (const fencePosStr of this.world.fences) {
                    const [gridX, gridY] = fencePosStr.split(',').map(Number);
                    const x = gridX * fenceSize;
                    const y = gridY * fenceSize;
                    this.ctx.fillRect(x, y, fenceSize, fenceSize);
                    this.ctx.strokeRect(x, y, fenceSize, fenceSize);
                }

                const cf = this.world.campfire;
                this.ctx.fillStyle = '#6b7280';
                this.ctx.beginPath();
                this.ctx.arc(cf.x, cf.y, cf.radius, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.strokeStyle = '#4b5563';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                if (this.gameState.isNight) {
                    this.ctx.fillStyle = 'rgba(255, 220, 150, 0.2)';
                    this.ctx.beginPath();
                    this.ctx.arc(cf.x, cf.y, cf.safeRadius, 0, Math.PI * 2);
                    this.ctx.fill();

                    const flameSize = cf.radius * 0.8;
                    const flameColor = Math.random() < 0.5 ? 'orange' : 'yellow';
                    this.ctx.fillStyle = flameColor;
                    this.ctx.beginPath();
                    this.ctx.moveTo(cf.x - flameSize / 2, cf.y + flameSize / 2);
                    this.ctx.quadraticCurveTo(cf.x, cf.y, cf.x, cf.y - flameSize * (1.5 + Math.random() * 0.5));
                    this.ctx.quadraticCurveTo(cf.x, cf.y, cf.x + flameSize / 2, cf.y + flameSize / 2);
                    this.ctx.fill();
                }
            }

            drawModePreview() {
                if (this.isBuildMode) {
                    const fenceSize = config.FENCE_SIZE;
                    const x = this.mouseGridPos.x * fenceSize;
                    const y = this.mouseGridPos.y * fenceSize;
                    const gridX = this.mouseGridPos.x;
                    const gridY = this.mouseGridPos.y;
                    const fenceKey = `${gridX},${gridY}`;

                    let previewColor = 'red'; 
                    if (this.world.fences.has(fenceKey)) {
                        previewColor = 'orange';
                    } else if (this.gameState.fences > 0) {
                        if (this.canPlaceFence(gridX, gridY)) {
                            previewColor = 'green';
                        }
                    }
                    this.ctx.globalAlpha = 0.5;
                    this.ctx.fillStyle = previewColor;
                    this.ctx.fillRect(x, y, fenceSize, fenceSize);
                    this.ctx.globalAlpha = 1.0;

                } else if (this.isCutMode) {
                    const tileSize = config.GRASS_TILE_SIZE;
                    const x = this.mouseGridPos.x * tileSize;
                    const y = this.mouseGridPos.y * tileSize;

                    let previewColor = 'rgba(255, 0, 0, 0.5)';
                    const tileInfo = this.getGrassTileAt(this.mouseGridPos.x, this.mouseGridPos.y);
                    if (tileInfo && tileInfo.tile.richness === tileInfo.tile.maxRichness) {
                        previewColor = 'rgba(0, 255, 0, 0.5)';
                    }
                    this.ctx.fillStyle = previewColor;
                    this.ctx.fillRect(x, y, tileSize, tileSize);
                }
            }

            getGrassTileAt(gridX, gridY) {
                const tileSize = config.GRASS_TILE_SIZE;
                for (const patch of this.world.grassPatches) {
                    const patchStartX = Math.floor(patch.x / tileSize);
                    const patchStartY = Math.floor(patch.y / tileSize);
                    const patchEndX = patchStartX + Math.floor(patch.width / tileSize);
                    const patchEndY = patchStartY + Math.floor(patch.height / tileSize);

                    if (gridX >= patchStartX && gridX < patchEndX && gridY >= patchStartY && gridY < patchEndY) {
                        const c = gridX - patchStartX;
                        const r = gridY - patchStartY;

                        if (patch.tiles[r] && patch.tiles[r][c]) {
                            return { patch, tile: patch.tiles[r][c] };
                        }
                    }
                }
                return null;
            }

            canPlaceFence(gridX, gridY) {
                const posStr = `${gridX},${gridY}`;
                if (this.world.fences.has(posStr)) return false;

                const fenceSize = config.FENCE_SIZE;
                const fenceBox = {
                    left: gridX * fenceSize,
                    right: (gridX + 1) * fenceSize,
                    top: gridY * fenceSize,
                    bottom: (gridY + 1) * fenceSize
                };

                const p = this.world.pasture;
                const trough = p.trough;
                const haystack = p.haystack;

                if (fenceBox.right > p.x - 5 && fenceBox.left < p.x + p.width + 5 &&
                    fenceBox.bottom > p.y - 5 && fenceBox.top < p.y + p.height + 5) {
                    return false;
                }
                if (fenceBox.right > trough.x && fenceBox.left < trough.x + trough.width &&
                    fenceBox.bottom > trough.y && fenceBox.top < trough.y + trough.height) {
                    return false;
                }
                const distToHaystack = utils.distance({ x: fenceBox.left + fenceSize / 2, y: fenceBox.top + fenceSize / 2 }, haystack);
                if (distToHaystack < haystack.radius + fenceSize / 2) return false;
                
                const cf = this.world.campfire;
                const distToCampfire = utils.distance({ x: fenceBox.left + fenceSize / 2, y: fenceBox.top + fenceSize / 2 }, cf);
                if (distToCampfire < cf.safeRadius + fenceSize / 2) return false;

                return true;
            }

            updateTime(deltaTime) {
                const prevHour = Math.floor((this.gameState.time - deltaTime / config.TIME_SCALE) / 60);
                this.gameState.time += deltaTime / config.TIME_SCALE;
                const currentHour = Math.floor(this.gameState.time / 60);

                if (this.gameState.time >= 24 * 60) {
                    this.gameState.time = this.gameState.time % (24 * 60);
                    this.gameState.day++;
                    this.endOfDay();
                }
                
                this.gameState.isNight = currentHour >= 18 || currentHour < 6;

                if (currentHour === 6 && prevHour === 5) {
                    this.startOfDay();
                }
            }
            
            startOfDay() {
                if (this._lastStartedDay === this.gameState.day) return;
                this._lastStartedDay = this.gameState.day;

                this.updateMerchantCycle(); 
                this.updateSeason();

                this.entities = this.entities.filter(e => !(e instanceof Wolf));
                this.world.pasture.gate.isOpen = true;
                this.logMessage(`ìƒˆë¡œìš´ ë‚ ì´ ë°ì•˜ìŠµë‹ˆë‹¤. Day ${this.gameState.day}`);

                const canGrassGrow = this.gameState.season === 'Spring' || this.gameState.season === 'Summer';

                if (canGrassGrow) {
                    this.world.grassPatches.forEach(p => {
                        p.tiles.forEach(row => row.forEach(tile => {
                            if (tile.richness === 0 && tile.regrowthTimer > 0) {
                                tile.regrowthTimer--;
                                if (tile.regrowthTimer === 0) {
                                    tile.richness = 1;
                                }
                            }
                        }));
                    });

                    if (this.gameState.day % 2 === 0) {
                        this.world.grassPatches.forEach(p => {
                            p.tiles.forEach(row => row.forEach(tile => {
                                if (tile.richness > 0 && tile.richness < tile.maxRichness) {
                                    tile.richness++;
                                }
                            }));
                        });
                    }
                }
                
                this.handleBreedingAndGrowth();
            }

            updateSeason() {
                const oldSeason = this.gameState.season;
                const seasonIndex = Math.floor((this.gameState.day - 1) / config.SEASON_LENGTH) % this.seasons.length;
                const newSeason = this.seasons[seasonIndex];

                if (oldSeason !== newSeason) {
                    this.gameState.season = newSeason;
                    this.logMessage(`ê³„ì ˆì´ ${this.gameState.season}(ìœ¼)ë¡œ ë°”ë€Œì—ˆìŠµë‹ˆë‹¤.`);

                    if (newSeason === 'Winter') {
                        this.world.grassPatches.forEach(p => p.tiles.forEach(row => row.forEach(tile => tile.richness = 0)));
                        this.logMessage("ê²¨ìš¸ì´ ë˜ì–´ ëª¨ë“  í’€ì´ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤.");
                    } else if (newSeason === 'Spring') {
                        this.world.grassPatches.forEach(p => {
                            for (let r = 0; r < p.tiles.length; r++) {
                                for (let c = 0; c < p.tiles[r].length; c++) {
                                    // ê²©ì íŒ¨í„´ì—ë§Œ í’€ì´ ìë¼ë„ë¡ í•¨
                                    if ((r + c) % 2 === 0) {
                                        p.tiles[r][c].richness = 1;
                                    }
                                }
                            }
                        });
                        this.logMessage("ë´„ì´ ë˜ì–´ í’€ì´ ë‹¤ì‹œ ìë¼ë‚˜ê¸° ì‹œì‘í•©ë‹ˆë‹¤.");
                    } else if (newSeason === 'Autumn') {
                        this.logMessage("ê°€ì„ì´ ë˜ì–´ í’€ì´ ë” ì´ìƒ ìë¼ì§€ ì•ŠìŠµë‹ˆë‹¤.");
                    }
                }
            }

            updateMerchantCycle() {
                this.gameState.merchantTimer--;
                if (this.gameState.merchantTimer <= 0) {
                    if (this.gameState.merchantState === 'present') {
                        this.gameState.merchantState = 'absent';
                        this.gameState.merchantTimer = 5;
                        this.despawnMerchant();
                        this.logMessage('ìƒì¸ì´ ë§ˆì„ì„ ë– ë‚¬ìŠµë‹ˆë‹¤.');
                    } else {
                        this.gameState.merchantState = 'present';
                        this.gameState.merchantTimer = 2;
                        this.spawnMerchant();
                        this.logMessage('ìƒì¸ì´ ë§ˆì„ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤.');
                    }
                }
            }

            spawnMerchant() {
                if (this.merchant) return;
                const cf = this.world.campfire;
                const angle = Math.random() * Math.PI * 2;
                const radius = cf.radius + Math.random() * (cf.safeRadius - cf.radius - 20);
                const x = cf.x + Math.cos(angle) * radius;
                const y = cf.y + Math.sin(angle) * radius;
                
                this.merchant = new Merchant(this, x, y);
                this.entities.push(this.merchant);
            }

            despawnMerchant() {
                if (this.merchant) {
                    this.merchant.isDead = true;
                    this.merchant = null;
                }
            }

            endOfDay() {
                if (this._lastEndedDay === this.gameState.day) return;
                this._lastEndedDay = this.gameState.day;
                this.entities.forEach(e => { if (e.endOfDay) e.endOfDay(); });
            }

            handleBreedingAndGrowth() {
                // MODIFIED: Sheep can now breed anywhere, not just in the pasture.
                const breedableAdults = this.entities.filter(e => e instanceof Sheep && e.isAdult && !e.breedingCooldown);
                let breedingPairs = Math.floor(breedableAdults.length / 2);
                for(let i = 0; i < breedingPairs; i++) {
                    const parent1 = breedableAdults[i*2];
                    const parent2 = breedableAdults[i*2+1];

                    // Spawn new lamb between the two parents
                    const spawnX = (parent1.x + parent2.x) / 2;
                    const spawnY = (parent1.y + parent2.y) / 2;

                    this.entities.push(new Sheep(this, spawnX, spawnY, false));
                    
                    parent1.breedingCooldown = 5;
                    parent2.breedingCooldown = 5;
                    this.logMessage("ìƒˆë¡œìš´ ìƒˆë¼ ì–‘ì´ íƒœì–´ë‚¬ìŠµë‹ˆë‹¤!");
                }
            }

            spawnWolves() {
                if (this.gameState.isNight && this.gameState.time >= config.WOLF_SPAWN_TIME) {
                    if (Math.random() < 0.001 * this.gameState.day) {
                        const side = Math.floor(Math.random() * 4);
                        let x, y;
                        if (side === 0) { x = 0; y = Math.random() * this.world.height; }
                        else if (side === 1) { x = this.world.width; y = Math.random() * this.world.height; }
                        else if (side === 2) { x = Math.random() * this.world.width; y = 0; }
                        else { x = Math.random() * this.world.height; y = this.world.height; }
                        this.entities.push(new Wolf(this, x, y));
                    }
                }
            }
            
            transferHay(direction, quantity) {
                const trough = this.world.pasture.trough;
                if (direction === 'toTrough') {
                    const tiles = trough.troughTiles;
                    const before = this.calculateTroughHayAmount();
                    let remaining = Math.min(quantity, this.gameState.hayStock);
                    while (remaining > 0) {
                        let movedThisRound = 0;
                        for (let i = 0; i < tiles.length && remaining > 0; i++) {
                            const tile = tiles[i];
                            if (tile.richness < tile.maxRichness) {
                                tile.richness += 1;
                                this.gameState.hayStock -= 1;
                                remaining -= 1;
                                movedThisRound++;
                            }
                        }
                        if (movedThisRound === 0) break;
                    }
                    trough.hayAmount = this.calculateTroughHayAmount();
                    const transferred = trough.hayAmount - before;
                    this.logMessage(`ê±´ì´ˆ ${transferred}ê°œë¥¼ ë¨¹ì´í†µì— ë„£ì—ˆìŠµë‹ˆë‹¤. (ë‚¨ì€ ê±´ì´ˆ: ${this.gameState.hayStock})`);
                } else if (direction === 'fromTrough') {
                    let amountToTransfer = quantity;
                    for (let i = 0; i < trough.troughTiles.length && amountToTransfer > 0; i++) {
                        const tile = trough.troughTiles[i];
                        const transferFromTile = Math.min(amountToTransfer, tile.richness);
                        if (transferFromTile > 0) {
                            tile.richness -= transferFromTile;
                            this.gameState.hayStock += transferFromTile;
                            amountToTransfer -= transferFromTile;
                        }
                    }
                    this.world.pasture.trough.hayAmount = this.calculateTroughHayAmount();
                    this.logMessage(`ê±´ì´ˆ ${quantity - amountToTransfer}ê°œë¥¼ ë¨¹ì´í†µì—ì„œ ì°½ê³ ë¡œ ì˜®ê²¼ìŠµë‹ˆë‹¤. (ì´ ê±´ì´ˆ: ${this.gameState.hayStock})`);
                }
            }

            updateLeaderSheep() {
                if (this.leaderSheep && !this.leaderSheep.isDead) return;
                if (this.leaderSheep) {
                    this.leaderSheep.isLeader = false;
                    this.leaderSheep = null;
                }
                const adultSheep = this.entities.filter(e => e instanceof Sheep && e.isAdult).sort((a, b) => a.age - b.age);
                if (adultSheep.length > 0) {
                    this.leaderSheep = adultSheep[0];
                    this.leaderSheep.isLeader = true;
                }
            }

            updateCamera() {
                this.camera.x = this.shepherd.x - this.canvas.width / 2;
                this.camera.y = this.shepherd.y - this.canvas.height / 2;
                this.camera.x = Math.max(0, Math.min(this.camera.x, this.world.width - this.canvas.width));
                this.camera.y = Math.max(0, Math.min(this.camera.y, this.world.height - this.canvas.height));
            }
            
            resizeCanvas() {
                const container = document.getElementById('game-container');
                if (container.clientWidth > 0 && container.clientHeight > 0) {
                    this.canvas.width = container.clientWidth;
                    this.canvas.height = container.clientHeight;
                }
            }

            checkGameOver() {
                if (this.shepherd.hp <= 0) {
                    this.gameState.gameOver = true;
                    this.ui.showGameOverModal();
                    this.logMessage(`ê²Œì„ ì˜¤ë²„! ${this.gameState.day}ì¼ ìƒì¡´í–ˆìŠµë‹ˆë‹¤.`);
                }
            }

            isInsidePasture(entity) {
                const p = this.world.pasture;
                return entity.x > p.x && entity.x < p.x + p.width && entity.y > p.y && entity.y < p.y + p.height;
            }

            isInsideCampfireZone(entity) {
                if (!this.world.campfire) return false;
                return utils.distance(entity, this.world.campfire) < this.world.campfire.safeRadius;
            }

            enterDogCommandMode(dog) {
                this.isDogCommandMode = true;
                this.dogToCommand = dog;
                this.ui.toggleDogInfoModal(false); // Close the modal
                this.logMessage(`${dog.name}ì—ê²Œ ì´ë™í•  ìœ„ì¹˜ë¥¼ ì§€ì •í•´ì£¼ì„¸ìš”.`);
                this.canvas.style.cursor = 'crosshair'; // Change cursor
            }

            logMessage(message) {
                const p = document.createElement('p');
                p.textContent = `[${this.ui.getFormattedTime()}] ${message}`;
                this.logDisplay.appendChild(p);
                this.logDisplay.scrollTop = this.logDisplay.scrollHeight;
            }

            // NEW: Obstacle check for Cheonlajimang skill
            isPositionObstructed(pos) {
                // Check player-built fences
                const fenceSize = config.FENCE_SIZE;
                const gridX = Math.floor(pos.x / fenceSize);
                const gridY = Math.floor(pos.y / fenceSize);
                if (this.world.fences.has(`${gridX},${gridY}`)) {
                    return true;
                }

                // Check pasture fence
                const p = this.world.pasture;
                const g = p.gate;
                const wallThickness = 10; // A bit of tolerance for the wall

                const isInsidePastureRect = pos.x > p.x && pos.x < p.x + p.width && pos.y > p.y && pos.y < p.y + p.height;
                const isInsidePastureWall = pos.x > p.x - wallThickness && pos.x < p.x + p.width + wallThickness && pos.y > p.y - wallThickness && pos.y < p.y + p.height + wallThickness;
                
                if (isInsidePastureWall && !isInsidePastureRect) {
                    // It's on the wall. Now check if it's the gate.
                    if (g.isOpen) {
                        const isAtGate = pos.x > g.x && pos.x < g.x + g.width && pos.y > p.y + p.height - wallThickness && pos.y < p.y + p.height + wallThickness;
                        if (isAtGate) {
                            return false; // It's the open gate, not an obstacle
                        }
                    }
                    return true; // It's on the wall
                }

                return false;
            }
        }

        class Character {
            constructor(game, x, y, radius, color) {
                this.game = game; this.x = x; this.y = y; this.radius = radius; this.color = color;
                this.hp = 100; this.maxHp = 100; this.speed = 1; this.target = null; this.isDead = false;
                this.name = '';
                this.deathLogged = false;
                this.hunger = 100;
                this.maxHunger = 100;
                // NEW: Stun and pull states
                this.stunTimer = 0;
                this.pullTarget = null;
                this.stunEffect = { active: false, timer: 0 };
            }
            update(deltaTime) {
                // NEW: Handle stun and pull states first
                if (this.stunTimer > 0) {
                    this.stunTimer--;
                    this.stunEffect.active = true;
                    this.stunEffect.timer++;
                    if (this.pullTarget) {
                        const dist = utils.distance(this, this.pullTarget);
                        if (dist > this.radius * 2) {
                            this.moveTowards(this.pullTarget, this.speed * 3); // Move faster when pulled
                        } else {
                            this.pullTarget = null;
                        }
                    }
                    return; // Skip normal movement while stunned
                } else {
                    this.stunEffect.active = false;
                    this.pullTarget = null;
                }

                if (this.hp <= 0 && !this.isDead) {
                    this.isDead = true;
                    if (!this.deathLogged) {
                        this.deathLogged = true;
                    }
                }
                
                if (this instanceof Shepherd || this instanceof Dog) {
                    this.hunger -= 0.01;
                    if (this.hunger <= 0) {
                        this.hunger = 0;
                        this.hp -= 0.02;
                        if (this.hp <= 0 && !this.isDead && !this.deathLogged) {
                            this.game.logMessage(`${this.name}ì´(ê°€) êµ¶ì£¼ë¦¼ìœ¼ë¡œ ì£½ì—ˆìŠµë‹ˆë‹¤.`);
                            this.deathLogged = true;
                        }
                    }
                }

                this.resolveCollisions();
                if (!this.game.gameState.isNight && this.hp < this.maxHp && !this.isDead) {
                    this.hp += 0.01;
                }
            }
            draw(ctx) {
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                
                let barY = this.y - this.radius - 12;
                if (this.name) {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.textAlign = 'center';
                    ctx.font = '10px sans-serif';
                    ctx.fillText(this.name, this.x, barY - 2);
                    barY -= 12;
                }

                if (this.hp < this.maxHp) {
                    ctx.fillStyle = '#555'; ctx.fillRect(this.x - this.radius, barY, this.radius * 2, 5);
                    const hpColor = this.hp > this.maxHp * 0.5 ? '#2ecc71' : (this.hp > this.maxHp * 0.25 ? '#f1c40f' : '#e74c3c');
                    ctx.fillStyle = hpColor; ctx.fillRect(this.x - this.radius, barY, this.radius * 2 * (this.hp / this.maxHp), 5);
                }

                if ((this instanceof Shepherd || this instanceof Dog) && this.hunger < this.maxHunger) {
                    ctx.fillStyle = '#7a5c58'; ctx.fillRect(this.x - this.radius, this.y + this.radius + 2, this.radius * 2, 4);
                    ctx.fillStyle = '#cdab7d'; ctx.fillRect(this.x - this.radius, this.y + this.radius + 2, this.radius * 2 * (this.hunger / this.maxHunger), 4);
                }
                
                // NEW: Draw stun effect
                if (this.stunEffect.active) {
                    ctx.save();
                    ctx.translate(this.x, this.y - this.radius - 15);
                    ctx.rotate(this.stunEffect.timer * 0.1);
                    ctx.fillStyle = 'yellow';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i * 2 * Math.PI / 3);
                        ctx.fillText('ğŸ’«', Math.cos(angle) * 12, Math.sin(angle) * 12);
                    }
                    ctx.restore();
                }
            }
            feed() {
                if (this.game.gameState.food > 0) {
                    this.game.gameState.food--;
                    this.hunger = Math.min(this.maxHunger, this.hunger + 50);
                    this.game.logMessage(`${this.name}ì—ê²Œ ìŒì‹ì„ ë¨¹ì˜€ìŠµë‹ˆë‹¤.`);
                } else {
                    this.game.logMessage("ìŒì‹ì´ ë¶€ì¡±í•©ë‹ˆë‹¤!");
                }
            }
            applyMovement(dx, dy) {
                this.x += dx;
                this.y += dy;
            }
            resolveCollisions() {
                this.game.entities.forEach(other => {
                    if (this === other || other.isDead) return;
                    const dist = utils.distance(this, other);
                    const minDist = this.radius + other.radius;
                    if (dist < minDist) {
                        const overlap = minDist - dist;
                        const angle = Math.atan2(this.y - other.y, this.x - other.x);
                        const pushX = Math.cos(angle) * overlap * 0.5;
                        const pushY = Math.sin(angle) * overlap * 0.5;
                        this.x += pushX; this.y += pushY;
                        other.x -= pushX; other.y -= pushY;
                    }
                });

                this.x = Math.max(this.radius, Math.min(this.x, this.game.world.width - this.radius));
                this.y = Math.max(this.radius, Math.min(this.y, this.game.world.height - this.radius));

                const p = this.game.world.pasture;
                const g = p.gate;
                const isInside = this.x > p.x && this.x < p.x + p.width && this.y > p.y && this.y < p.y + p.height;
                
                if (isInside) {
                    if (this.x - this.radius < p.x) this.x = p.x + this.radius;
                    if (this.x + this.radius > p.x + p.width) this.x = p.x + p.width - this.radius;
                    if (this.y - this.radius < p.y) this.y = p.y + this.radius;
                    if (this.y + this.radius > p.y + p.height) {
                        const inGateX = this.x > g.x && this.x < g.x + g.width;
                        if (!g.isOpen || !inGateX) {
                            this.y = p.y + p.height - this.radius;
                        }
                    }
                } else {
                    const charBox = { left: this.x - this.radius, right: this.x + this.radius, top: this.y - this.radius, bottom: this.y + this.radius };
                    const fenceBox = { left: p.x, right: p.x + p.width, top: p.y, bottom: p.y + p.height };
                    if (charBox.right > fenceBox.left && charBox.left < fenceBox.right && charBox.bottom > fenceBox.top && charBox.top < fenceBox.bottom) {
                        const inGateX = this.x > g.x && this.x < g.x + g.width;
                        const atGateY = Math.abs(this.y - (p.y + p.height)) < this.radius;
                        if (!g.isOpen || !inGateX || !atGateY) {
                            const dx = (this.x - (p.x + p.width / 2));
                            const dy = (this.y - (p.y + p.height / 2));
                            const overlapX = (this.radius + p.width / 2) - Math.abs(dx);
                            const overlapY = (this.radius + p.height / 2) - Math.abs(dy);
                            if (overlapX < overlapY) {
                                this.x += (dx > 0 ? overlapX : -overlapX);
                            } else {
                                this.y += (dy > 0 ? overlapY : -overlapY);
                            }
                        }
                    }
                }

                const fenceSize = config.FENCE_SIZE;
                const gridX = Math.floor(this.x / fenceSize);
                const gridY = Math.floor(this.y / fenceSize);

                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const key = `${gridX + i},${gridY + j}`;
                        if (this.game.world.fences.has(key)) {
                            const fenceX = (gridX + i) * fenceSize;
                            const fenceY = (gridY + j) * fenceSize;

                            const closestX = Math.max(fenceX, Math.min(this.x, fenceX + fenceSize));
                            const closestY = Math.max(fenceY, Math.min(this.y, fenceY + fenceSize));
                            const distance = utils.distance({x: this.x, y: this.y}, {x: closestX, y: closestY});

                            if (distance < this.radius) {
                                const overlap = this.radius - distance;
                                const angle = Math.atan2(this.y - closestY, this.x - closestX);
                                
                                if (distance > 0) {
                                    this.x += Math.cos(angle) * overlap;
                                    this.y += Math.sin(angle) * overlap;
                                } else {
                                    const dx = this.x - (fenceX + fenceSize / 2);
                                    const dy = this.y - (fenceY + fenceSize / 2);
                                    const overlapX = (this.radius + fenceSize / 2) - Math.abs(dx);
                                    const overlapY = (this.radius + fenceSize / 2) - Math.abs(dy);
                                    if (overlapX < overlapY) {
                                        this.x += dx > 0 ? overlapX : -overlapX;
                                    } else {
                                        this.y += dy > 0 ? overlapY : -overlapY;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            moveTowards(target, speed) {
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                const dx = Math.cos(angle) * speed; const dy = Math.sin(angle) * speed;
                this.applyMovement(dx, dy);
            }
        }

        class Shepherd extends Character {
            constructor(game, x, y) { 
                super(game, x, y, 15, '#3498db'); 
                this.speed = config.SHEPHERD_SPEED; 
                this.name = 'ì–‘ì¹˜ê¸°';
                this.draggedSheep = [];
                // NEW: Skill cooldown
                this.skillCooldown = 0;
                this.maxSkillCooldown = 600; // 10 seconds at 60fps
            }
            update(deltaTime) {
                if (this.skillCooldown > 0) {
                    this.skillCooldown--;
                }

                const dxInput = this.game.input.moveX;
                const dyInput = this.game.input.moveY;
                
                if (dxInput !== 0 || dyInput !== 0) {
                    const magnitude = Math.sqrt(dxInput * dxInput + dyInput * dyInput);
                    const dx = (dxInput / magnitude) * this.speed; 
                    const dy = (dyInput / magnitude) * this.speed;
                    this.applyMovement(dx, dy);
                }
                
                this.draggedSheep.forEach((sheep, index) => {
                    const angle = Math.atan2(this.y - sheep.y, this.x - sheep.x);
                    const targetDist = this.radius + sheep.radius + 10 + (index * 5);
                    const targetX = this.x - Math.cos(angle) * targetDist;
                    const targetY = this.y - Math.sin(angle) * targetDist;
                    
                    sheep.x += (targetX - sheep.x) * 0.1;
                    sheep.y += (targetY - sheep.y) * 0.1;
                });
                
                super.update(deltaTime);
            }

            draw(ctx) {
                super.draw(ctx);
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                this.draggedSheep.forEach(sheep => {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(sheep.x, sheep.y);
                    ctx.stroke();
                });
            }

            toggleDragSheep(sheep) {
                const isDragging = this.draggedSheep.includes(sheep);

                if (isDragging) {
                    this.draggedSheep = this.draggedSheep.filter(s => s !== sheep);
                    sheep.isDragged = false;
                    this.game.logMessage(`${sheep.name}ì„(ë¥¼) ë†“ì•„ì£¼ì—ˆìŠµë‹ˆë‹¤.`);
                } else {
                    const adultsDragged = this.draggedSheep.filter(s => s.isAdult).length;
                    const lambsDragged = this.draggedSheep.filter(s => !s.isAdult).length;

                    if (sheep.isAdult) {
                        if (adultsDragged === 0 && lambsDragged === 0) {
                            this.draggedSheep.push(sheep);
                            sheep.isDragged = true;
                            this.game.logMessage(`${sheep.name}ì„(ë¥¼) ëŒê³  ë‹¤ë‹™ë‹ˆë‹¤.`);
                        } else {
                            this.game.logMessage("ì„±ì¸ ì–‘ì€ í•œ ë§ˆë¦¬ë§Œ ëŒ ìˆ˜ ìˆìœ¼ë©°, ë‹¤ë¥¸ ì–‘ê³¼ í•¨ê»˜ ëŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                        }
                    } else {
                        if (adultsDragged === 0 && lambsDragged < 2) {
                            this.draggedSheep.push(sheep);
                            sheep.isDragged = true;
                            this.game.logMessage(`${sheep.name}ì„(ë¥¼) ëŒê³  ë‹¤ë‹™ë‹ˆë‹¤.`);
                        } else {
                            this.game.logMessage("ìƒˆë¼ ì–‘ì€ ìµœëŒ€ ë‘ ë§ˆë¦¬ê¹Œì§€ ëŒ ìˆ˜ ìˆìœ¼ë©°, ì„±ì¸ ì–‘ê³¼ í•¨ê»˜ ëŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                        }
                    }
                }
            }
        }

        class Merchant extends Character {
            constructor(game, x, y) {
                super(game, x, y, 18, '#8e44ad');
                this.name = 'ìƒì¸';
                this.speed = 1.5;
                this.hp = Infinity;
                this.maxHp = Infinity;
                this.hunger = Infinity;
            }

            update(deltaTime) {
                if (!this.game.isInsideCampfireZone(this)) {
                    this.moveTowards(this.game.world.campfire, this.speed);
                }
                super.update(deltaTime);
            }

            draw(ctx) {
                super.draw(ctx);
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = '18px sans-serif';
                ctx.fillText('ğŸ’°', this.x, this.y + 6);
            }
        }
        
        class Sheep extends Character {
            constructor(game, x, y, isAdult) {
                super(game, x, y, isAdult ? 12 : 8, 'white');
                this.speed = config.SHEEP_SPEED;
                this.isAdult = isAdult;
                this.age = isAdult ? 7 : 0;
                this.breedingCooldown = 0;
                this.shearCooldown = 0;
                this.isSheared = false;
                this.state = 'wandering';
                this.stateTimer = 0;
                this.maxHp = 50;
                this.hp = 50;
                this.vx = 0;
                this.vy = 0;
                this.isLeader = false;
                this.name = `ì–‘ #${Math.floor(Math.random() * 1000)}`;
                this.perceptionRange = 100;
                this.eatingTimer = 0;
                this.isDragged = false;
            }

            update(deltaTime) {
                super.update(deltaTime);
                if (this.stunTimer > 0) return; // if stunned, skip behavior logic

                this.stateTimer -= 1;
                this.hunger -= 0.01;
                if (this.hunger <= 0) {
                    this.hp -= 0.02;
                    this.hunger = 0;
                    if (this.hp <= 0 && !this.isDead && !this.deathLogged) {
                        this.game.logMessage(`${this.name}ì´(ê°€) êµ¶ì£¼ë¦¼ìœ¼ë¡œ ì£½ì—ˆìŠµë‹ˆë‹¤.`);
                        this.deathLogged = true;
                    }
                }

                if (this.isDragged) {
                    return;
                }
                
                const dangers = this.game.entities.filter(e => 
                    (e instanceof Wolf && utils.distance(this, e) < 200) ||
                    ((e instanceof Shepherd || e instanceof Dog) && utils.distance(this, e) < 100)
                );
                const currentFoodSource = this.getCurrentFoodSource();

                if (dangers.length > 0) {
                    this.state = 'fleeing';
                } else if (currentFoodSource && this.hunger < 95) {
                    this.state = 'eating';
                } else if (this.hunger <= 50) {
                    const foodTarget = this.findClosestFood();
                    if (foodTarget) {
                        this.state = 'seeking_food';
                        this.target = foodTarget;
                    } else {
                        if (!this.isAdult && this.findClosest(Sheep, this.perceptionRange, s => s.isAdult)) {
                            this.state = 'following_adult';
                        } else if (this.isAdult && !this.isLeader && this.game.leaderSheep && this.game.leaderSheep !== this) {
                            this.state = 'following_leader';
                        } else {
                            this.state = 'wandering';
                        }
                    }
                } else {
                    if (!this.isAdult && this.findClosest(Sheep, this.perceptionRange, s => s.isAdult)) {
                        this.state = 'following_adult';
                    } else if (!this.isLeader && this.game.leaderSheep && this.game.leaderSheep !== this) {
                        this.state = 'following_leader';
                    } else {
                        this.state = 'wandering';
                    }
                }

                let finalDx = 0, finalDy = 0;
                let isMoving = true;

                switch (this.state) {
                    case 'fleeing':
                        let avgX = 0, avgY = 0;
                        dangers.forEach(d => { avgX += d.x; avgY += d.y; });
                        avgX /= dangers.length;
                        avgY /= dangers.length;
                        const fleeAngle = Math.atan2(this.y - avgY, this.x - avgX);
                        finalDx = Math.cos(fleeAngle);
                        finalDy = Math.sin(fleeAngle);
                        break;
                    case 'eating':
                        isMoving = false;
                        this.eatingTimer -= deltaTime;
                        if (this.eatingTimer <= 0) {
                            if (currentFoodSource.type === 'grass') {
                                this.hunger = Math.min(100, this.hunger + 10);
                                currentFoodSource.tileObject.richness--;
                                this.game.logMessage(`${this.name}ì´(ê°€) í’€ì„ ë¨¹ì–´ ë°°ë¶€ë¦„ì´ 10 ì˜¬ëìŠµë‹ˆë‹¤.`);
                                if (currentFoodSource.tileObject.richness <= 0) {
                                    currentFoodSource.tileObject.regrowthTimer = 10;
                                }
                            } else if (currentFoodSource.type === 'hay') {
                                this.hunger = Math.min(100, this.hunger + 30);
                                currentFoodSource.tileObject.richness--;
                                this.game.world.pasture.trough.hayAmount = this.game.calculateTroughHayAmount();
                                this.game.logMessage(`${this.name}ì´(ê°€) ê±´ì´ˆì„(ë¥¼) ë¨¹ì–´ ë°°ë¶€ë¦„ì´ 30 ì˜¬ëìŠµë‹ˆë‹¤.`);
                            }
                            this.eatingTimer = config.GRASS_EATING_DELAY;
                        }
                        break;
                    case 'seeking_food':
                        if (this.target) {
                            const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                            finalDx = Math.cos(angle);
                            finalDy = Math.sin(angle);
                        } else {
                           isMoving = false;
                        }
                        break;
                    case 'following_leader':
                        const leader = this.game.leaderSheep;
                        if (leader && utils.distance(this, leader) > 50) {
                            const angle = Math.atan2(leader.y - this.y, leader.x - this.x);
                            finalDx = Math.cos(angle);
                            finalDy = Math.sin(angle);
                        }
                        const cohesion_leader = this.calculateCohesionVector(30);
                        finalDx += cohesion_leader.dx * 0.5;
                        finalDy += cohesion_leader.dy * 0.5;
                        break;
                    case 'following_adult':
                        const adult = this.findClosest(Sheep, this.perceptionRange, s => s.isAdult);
                        if (adult && utils.distance(this, adult) > 50) {
                            const angle = Math.atan2(adult.y - this.y, adult.x - this.x);
                            finalDx = Math.cos(angle);
                            finalDy = Math.sin(angle);
                        }
                        const cohesion_adult = this.calculateCohesionVector(30);
                        finalDx += cohesion_adult.dx * 0.5;
                        finalDy += cohesion_adult.dy * 0.5;
                        break;
                    case 'wandering':
                        if (this.stateTimer <= 0 || !this.target || utils.distance(this, this.target) < 10) {
                            this.target = { x: this.x + (Math.random() - 0.5) * 200, y: this.y + (Math.random() - 0.5) * 200 };
                            this.stateTimer = Math.random() * 300 + 200;
                        }
                        if (this.target) {
                            const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                            finalDx = Math.cos(angle);
                            finalDy = Math.sin(angle);
                        }
                        const cohesion_wander = this.calculateCohesionVector(30);
                        finalDx += cohesion_wander.dx * 0.8;
                        finalDy += cohesion_wander.dy * 0.8;
                        break;
                }

                let desiredVx = 0, desiredVy = 0;
                const magnitude = Math.sqrt(finalDx * finalDx + finalDy * finalDy);
                if (magnitude > 0) {
                    let currentSpeed = this.speed;
                    if (this.state === 'fleeing') currentSpeed *= 1.5;
                    else if (this.state === 'wandering') currentSpeed *= 0.7;
                    desiredVx = (finalDx / magnitude) * currentSpeed;
                    desiredVy = (finalDy / magnitude) * currentSpeed;
                }

                if (isMoving) {
                    const steeringFactor = 0.05;
                    this.vx = this.vx * (1 - steeringFactor) + desiredVx * steeringFactor;
                    this.vy = this.vy * (1 - steeringFactor) + desiredVy * steeringFactor;
                } else {
                    this.vx *= 0.8;
                    this.vy *= 0.8;
                }

                if (Math.abs(this.vx) > 0.01 || Math.abs(this.vy) > 0.01) {
                    this.applyMovement(this.vx, this.vy);
                }
            }

            calculateCohesionVector(flockDistance) {
                let avgX = 0, avgY = 0;
                let separationDx = 0, separationDy = 0;
                let count = 0;
                const flockmates = this.game.entities.filter(e => e instanceof Sheep && e !== this && utils.distance(this, e) < this.perceptionRange);

                if (flockmates.length > 0) {
                    flockmates.forEach(fm => {
                        const dist = utils.distance(this, fm);
                        if (dist < flockDistance) {
                            const angle = Math.atan2(this.y - fm.y, this.x - fm.x);
                            separationDx += Math.cos(angle);
                            separationDy += Math.sin(angle);
                        }
                        avgX += fm.x;
                        avgY += fm.y;
                        count++;
                    });

                    if (count > 0) {
                        avgX /= count;
                        avgY /= count;
                        const angleToCenter = Math.atan2(avgY - this.y, avgX - this.x);
                        return {
                            dx: Math.cos(angleToCenter) + separationDx,
                            dy: Math.sin(angleToCenter) + separationDy
                        };
                    }
                }
                return { dx: 0, dy: 0 };
            }

            getCurrentFoodSource() {
                if (this.game.isInsidePasture(this)) {
                    const trough = this.game.world.pasture.trough;
                    const troughTileWidth = trough.width / trough.numTroughTiles;
                    if (this.x >= trough.x && this.x <= trough.x + trough.width &&
                        this.y >= trough.y && this.y <= trough.y + trough.height) {
                        const tileIndex = Math.floor((this.x - trough.x) / troughTileWidth);
                        const tile = trough.troughTiles[tileIndex];
                        if (tile && tile.richness > 0) {
                            return { type: 'hay', tileObject: tile };
                        }
                    }
                }
                else {
                    for (const patch of this.game.world.grassPatches) {
                        if (this.x > patch.x && this.x < patch.x + patch.width && this.y > patch.y && this.y < patch.y + patch.height) {
                            const c = Math.floor((this.x - patch.x) / config.GRASS_TILE_SIZE);
                            const r = Math.floor((this.y - patch.y) / config.GRASS_TILE_SIZE);
                            if (patch.tiles[r] && patch.tiles[r][c] && patch.tiles[r][c].richness > 0) {
                                return { type: 'grass', tileObject: patch.tiles[r][c] };
                            }
                        }
                    }
                }
                return null;
            }

            findClosestFood() {
                if (this.game.isInsidePasture(this)) {
                    const trough = this.game.world.pasture.trough;
                    let closestHayTile = null;
                    let minDistToHayTile = Infinity;
                    trough.troughTiles.forEach((tile, index) => {
                        if (tile.richness > 0) {
                            const tileCenter = {
                                x: trough.x + index * (trough.width / trough.numTroughTiles) + (trough.width / trough.numTroughTiles) / 2,
                                y: trough.y + trough.height / 2
                            };
                            const dist = utils.distance(this, tileCenter);
                            if (dist < minDistToHayTile) {
                                minDistToHayTile = dist;
                                closestHayTile = tileCenter;
                            }
                        }
                    });
                    return closestHayTile;
                }
                else {
                    let closestGrass = null;
                    let min_dist = this.perceptionRange;
                    this.game.world.grassPatches.forEach(p => {
                        for (let r = 0; r < p.tiles.length; r++) {
                            for (let c = 0; c < p.tiles[r].length; c++) {
                                if (p.tiles[r][c].richness > 0) {
                                    const tilePos = { x: p.x + (c + 0.5) * config.GRASS_TILE_SIZE, y: p.y + (r + 0.5) * config.GRASS_TILE_SIZE };
                                    const d = utils.distance(this, tilePos);
                                    if (d < min_dist) {
                                        min_dist = d;
                                        closestGrass = tilePos;
                                    }
                                }
                            }
                        }
                    });
                    return closestGrass;
                }
            }
            
            draw(ctx) {
                const originalColor = this.color;
                if (this.isSheared) this.color = '#cccccc';
                if (this.isDragged) this.color = '#f1c40f';
                
                super.draw(ctx);
                
                this.color = originalColor;
                
                if (this.isLeader) {
                    ctx.fillStyle = 'gold';
                    ctx.font = '16px sans-serif';
                    ctx.fillText('ğŸ‘‘', this.x, this.y - this.radius - (this.name ? 25 : 15) - (this.hp < this.maxHp ? 12 : 0));
                }
                if (this.hunger < 100) {
                    ctx.fillStyle = '#7a5c58'; ctx.fillRect(this.x - this.radius, this.y + this.radius + 2, this.radius * 2, 4);
                    ctx.fillStyle = '#cdab7d'; ctx.fillRect(this.x - this.radius, this.y + this.radius + 2, this.radius * 2 * (this.hunger / 100), 4);
                }
            }

            findClosest(type, range, filter = () => true) {
                let closest = null, min_dist = range;
                this.game.entities.forEach(e => {
                    if (e instanceof type && e !== this && filter(e)) { const d = utils.distance(this, e);
                        if (d < min_dist) { min_dist = d; closest = e; }
                    }
                });
                return closest;
            }
            endOfDay() {
                this.age++;
                if (!this.isAdult && this.age >= 7) { this.isAdult = true; this.radius = 12; }
                if (this.breedingCooldown > 0) this.breedingCooldown--;
                if (this.shearCooldown > 0) {
                    this.shearCooldown--;
                    if (this.shearCooldown === 0) {
                        this.isSheared = false;
                    }
                }
            }
        }

        class Dog extends Character {
            constructor(game, x, y) {
                super(game, x, y, 13, '#a0522d'); 
                this.speed = config.DOG_SPEED; 
                this.command = 'follow'; // 'follow', 'stay', 'move_to'
                this.stance = 'Guard'; // 'Guard' or 'Peace'
                this.maxHp = 150; 
                this.hp = 150;
                this.name = `ê°œ #${Math.floor(Math.random() * 1000)}`;
                this.id = ++game.idCounters.dog;
                this.moveTarget = null;
            }
            update(deltaTime) {
                super.update(deltaTime);
                if (this.stunTimer > 0) return; // if stunned, skip behavior logic

                let isActing = false;

                if (this.stance === 'Guard') {
                    const wolf = this.findClosest(Wolf, 200);
                    if (wolf) {
                        isActing = true;
                        this.target = wolf;
                        this.moveTowards(this.target, this.speed);
                        if (utils.distance(this, this.target) < this.radius + this.target.radius) {
                            wolf.hp -= 0.5;
                            if (wolf.hp <= 0 && !wolf.isDead && !wolf.deathLogged) {
                                this.game.logMessage(`${this.name}ì´(ê°€) ëŠ‘ëŒ€ ${wolf.name || ''}ë¥¼ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤.`);
                                wolf.deathLogged = true;
                            }
                        }
                    }
                }

                if (!isActing) {
                    if (this.command === 'move_to' && this.moveTarget) {
                        this.moveTowards(this.moveTarget, this.speed);
                        if (utils.distance(this, this.moveTarget) < this.radius) {
                            this.command = 'stay';
                            this.moveTarget = null;
                            this.game.dogMoveMarkers = this.game.dogMoveMarkers.filter(m => m.dogId !== this.id);
                        }
                    } else if (this.command === 'follow' && utils.distance(this, this.game.shepherd) > 50) {
                        this.moveTowards(this.game.shepherd, this.speed);
                    }
                }
            }
            findClosest(type, range) {
                let closest = null, min_dist = range;
                this.game.entities.forEach(e => {
                    if (e instanceof type && !e.isDead && !this.game.isInsideCampfireZone(e)) { 
                        const d = utils.distance(this, e);
                        if (d < min_dist) { min_dist = d; closest = e; }
                    }
                });
                return closest;
            }
        }
        
        class Wolf extends Character {
            constructor(game, x, y) {
                super(game, x, y, 16, '#555'); 
                this.speed = config.WOLF_SPEED; 
                this.maxHp = 100; 
                this.hp = 100;
                this._skinDropped = false;
                this.name = `ëŠ‘ëŒ€ #${Math.floor(Math.random() * 1000)}`;
            }
            update(deltaTime) {
                super.update(deltaTime);
                if (this.stunTimer > 0) return; // if stunned, skip behavior logic

                const game = this.game;
                if (!game || this.isDead) return;

                if (this.target && game.isInsideCampfireZone(this.target)) {
                    this.target = null;
                }

                if (this.hp <= 0 && !this._skinDropped) {
                    game.gameState.wolfSkin++;
                    game.logMessage(`ëŠ‘ëŒ€ ${this.name || ''}ê°€ ì£½ê³  ëŠ‘ëŒ€ ê°€ì£½ì„ íšë“í–ˆìŠµë‹ˆë‹¤. (ì´ ${game.gameState.wolfSkin}ê°œ)`);
                    this._skinDropped = true;
                    this.isDead = true;
                    this.deathLogged = true;
                    return;
                }

                if (!this.target || this.target.isDead) {
                    this.target = this.findTarget();
                }

                if (this.target) {
                    this.moveTowards(this.target, this.speed);
                    if (utils.distance(this, this.target) < this.radius + this.target.radius) {
                        this.target.hp -= 1;
                        if (this.target.hp <= 0 && !this.target.isDead && !this.target.deathLogged) {
                            if (this.target instanceof Sheep) {
                                game.logMessage(`ëŠ‘ëŒ€ ${this.name || ''}ì´(ê°€) ${this.target.name}ì„(ë¥¼) ê³µê²©í•˜ì—¬ ì£½ì˜€ìŠµë‹ˆë‹¤.`);
                                this.target.deathLogged = true;
                                this.target.hp = 0;
                            } else if (this.target instanceof Shepherd) {
                                game.logMessage(`ëŠ‘ëŒ€ ${this.name || ''}ì´(ê°€) ì–‘ì¹˜ê¸° ${this.target.name || ''}ë¥¼ ê³µê²©í•˜ì—¬ ì£½ì˜€ìŠµë‹ˆë‹¤.`);
                                this.target.deathLogged = true;
                            } else if (this.target instanceof Dog) {
                                game.logMessage(`ëŠ‘ëŒ€ ${this.name || ''}ì´(ê°€) ê°œ ${this.target.name || ''}ë¥¼ ê³µê²©í•˜ì—¬ ì£½ì˜€ìŠµë‹ˆë‹¤.`);
                                this.target.deathLogged = true;
                            }
                        }
                    }
                }

                if (game.world && game.isInsideCampfireZone(this)) {
                    const cf = game.world.campfire;
                    const dist = utils.distance(this, cf);
                    if (dist < cf.safeRadius) {
                        const overlap = cf.safeRadius - dist;
                        const angle = Math.atan2(this.y - cf.y, this.x - cf.x);
                        this.x += Math.cos(angle) * (overlap + 1);
                        this.y += Math.sin(angle) * (overlap + 1);
                    }
                }
            }
            findTarget() {
                const game = this.game;
                if (!game || !game.world) return null;
                
                let potentialTargets = game.entities.filter(e => 
                    (e instanceof Sheep || e instanceof Dog || e instanceof Shepherd) && 
                    !e.isDead &&
                    !game.isInsideCampfireZone(e)
                );
                potentialTargets.sort((a,b) => utils.distance(this, a) - utils.distance(this, b));
                return potentialTargets[0] || null;
            }
        }
        
        class InputHandler {
            constructor(game) {
                this.game = game; this.keys = {}; this.moveX = 0; this.moveY = 0;
                this.isDrawing = false; // For skill
                window.addEventListener('keydown', e => { this.keys[e.key] = true; });
                window.addEventListener('keyup', e => { this.keys[e.key] = false; });
                this.joystick = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, maxDistance: 50 };
                if (utils.isMobile()) {
                    document.getElementById('joystick').classList.remove('hidden');
                    this.game.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
                    this.game.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
                    this.game.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
                }
                // Combined event listeners
                this.game.canvas.addEventListener('mousedown', this.handlePrimaryDown.bind(this));
                this.game.canvas.addEventListener('mousemove', this.handlePrimaryMove.bind(this));
                window.addEventListener('mouseup', this.handlePrimaryUp.bind(this));
                this.game.canvas.addEventListener('touchstart', this.handlePrimaryDown.bind(this), { passive: false });
                this.game.canvas.addEventListener('touchmove', this.handlePrimaryMove.bind(this), { passive: false });
                window.addEventListener('touchend', this.handlePrimaryUp.bind(this));
            }
            update() {
                this.moveX = 0; this.moveY = 0;
                if (this.keys['w'] || this.keys['W'] || this.keys['ArrowUp']) this.moveY -= 1;
                if (this.keys['s'] || this.keys['S'] || this.keys['ArrowDown']) this.moveY += 1;
                if (this.keys['a'] || this.keys['A'] || this.keys['ArrowLeft']) this.moveX -= 1;
                if (this.keys['d'] || this.keys['D'] || this.keys['ArrowRight']) this.moveX += 1;

                if (this.joystick.active) {
                    const dx = this.joystick.currentX - this.joystick.startX;
                    const dy = this.joystick.currentY - this.joystick.startY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        this.moveX = dx / dist;
                        this.moveY = dy / dist;
                    } else {
                        this.moveX = 0; this.moveY = 0;
                    }
                }
            }
            handleTouchStart(e) {
                const touch = e.touches[0]; const rect = this.game.canvas.getBoundingClientRect();
                const joystickBase = document.getElementById('joystick');
                joystickBase.style.left = `${touch.clientX - rect.left - 60}px`; joystickBase.style.top = `${touch.clientY - rect.top - 60}px`;
                this.joystick.active = true; this.joystick.startX = touch.clientX; this.joystick.startY = touch.clientY;
                this.joystick.currentX = touch.clientX; this.joystick.currentY = touch.clientY;
            }
            handleTouchMove(e) {
                if (!this.joystick.active) return; e.preventDefault();
                const touch = e.touches[0]; this.joystick.currentX = touch.clientX; this.joystick.currentY = touch.clientY;
                const dx = this.joystick.currentX - this.joystick.startX; const dy = this.joystick.currentY - this.joystick.startY;
                let dist = Math.sqrt(dx*dx + dy*dy);
                const handle = document.getElementById('joystick-handle');
                if (dist > this.joystick.maxDistance) handle.style.transform = `translate(${dx/dist * this.joystick.maxDistance}px, ${dy/dist * this.joystick.maxDistance}px)`;
                else handle.style.transform = `translate(${dx}px, ${dy}px)`;
            }
            handleTouchEnd(e) {
                this.joystick.active = false; this.moveX = 0; this.moveY = 0;
                document.getElementById('joystick-handle').style.transform = `translate(0px, 0px)`;
            }
            
            // NEW: Combined input handlers
            getPointerWorldPos(e) {
                const rect = this.game.canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: clientX - rect.left + this.game.camera.x,
                    y: clientY - rect.top + this.game.camera.y
                };
            }

            handlePrimaryDown(e) {
                if (this.game.isSkillMode) {
                    e.preventDefault();
                    this.isDrawing = true;
                    this.game.skillPath = [this.getPointerWorldPos(e)];
                }
            }
            
            handlePrimaryMove(e) {
                const worldPos = this.getPointerWorldPos(e);
                
                // Skill drawing logic
                if (this.isDrawing && this.game.isSkillMode) {
                    e.preventDefault();
                    
                    // MODIFIED: Check for collision with obstacles
                    if (this.game.isPositionObstructed(worldPos)) {
                        this.game.logMessage("ì²œë¼ì§€ë§ì´ ì¥ì• ë¬¼ì— ë§‰í˜€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.");
                        this.isDrawing = false;
                        this.game.isSkillMode = false;
                        this.game.skillPath = [];
                        this.game.canvas.style.cursor = 'pointer';
                        return;
                    }

                    this.game.skillPath.push(worldPos);
                }
                
                // Build/Cut mode preview logic
                if (this.game.isBuildMode || this.game.isCutMode) {
                    const gridSize = this.game.isBuildMode ? config.FENCE_SIZE : config.GRASS_TILE_SIZE;
                    this.game.mouseGridPos = {
                        x: Math.floor(worldPos.x / gridSize),
                        y: Math.floor(worldPos.y / gridSize)
                    };
                }
            }

            handlePrimaryUp(e) {
                if (this.isDrawing && this.game.isSkillMode) {
                    this.handleDrawEnd();
                    return;
                }
                
                // If it was a click/tap (not a drag for joystick or skill), handle clicks.
                // A simple check: if the event is a mouseup or touchend, and we weren't drawing, it's a click.
                if (!this.isDrawing) {
                    this.handleCanvasClick(e);
                }
            }

            handleDrawEnd() {
                if (!this.isDrawing || !this.game.isSkillMode) return;
                this.isDrawing = false;

                if (this.game.skillPath.length > 20) {
                    const path = this.game.skillPath;
                    const intersections = [];
                    for (let i = 0; i < path.length - 2; i++) {
                        for (let j = i + 15; j < path.length - 2; j++) {
                            const p1 = path[i];
                            const p2 = path[i+1];
                            const p3 = path[j];
                            const p4 = path[j+1];
                            const intersectPoint = utils.getLineIntersection(p1, p2, p3, p4);
                            if (intersectPoint) {
                                intersections.push({point: intersectPoint, i1: i, i2: j});
                            }
                        }
                    }

                    if (intersections.length > 0) {
                        const firstIntersection = intersections[0];
                        const loopPolygon = path.slice(firstIntersection.i1 + 1, firstIntersection.i2 + 1);
                        loopPolygon.push(firstIntersection.point);

                        const entitiesToCatch = [];
                        this.game.entities.forEach(entity => {
                            if ((entity instanceof Sheep || entity instanceof Dog || entity instanceof Wolf) && !entity.isDead) {
                                if (utils.pointInPolygon(entity, loopPolygon)) {
                                    entitiesToCatch.push(entity);
                                }
                            }
                        });

                        if (entitiesToCatch.length > 0) {
                            this.game.logMessage(`ì²œë¼ì§€ë§ìœ¼ë¡œ ${entitiesToCatch.length}ë§ˆë¦¬ë¥¼ í¬íší–ˆìŠµë‹ˆë‹¤!`);
                            this.game.effects.push({ type: 'polygon', polygon: loopPolygon, endTime: Date.now() + 500, duration: 500 });

                            entitiesToCatch.forEach(e => {
                                e.hp = Math.max(0, e.hp - 20);
                                e.stunTimer = 180; // 3 seconds stun
                                e.pullTarget = { x: this.game.shepherd.x, y: this.game.shepherd.y };
                                if (e.hp <= 0 && !e.isDead) {
                                    e.isDead = true;
                                    if (!e.deathLogged) {
                                        this.game.logMessage(`${e.name}ì´(ê°€) ì²œë¼ì§€ë§ì˜ ì¶©ê²©ìœ¼ë¡œ ì£½ì—ˆìŠµë‹ˆë‹¤.`);
                                        e.deathLogged = true;
                                    }
                                }
                            });
                            this.game.shepherd.skillCooldown = this.game.shepherd.maxSkillCooldown;
                        }
                    }
                }

                this.game.isSkillMode = false;
                this.game.canvas.style.cursor = 'pointer';
                this.game.skillPath = [];
            }

            handleCanvasClick(e) {
                if (this.game.isSkillMode) return;
                
                const worldPos = this.getPointerWorldPos(e);
                const worldX = worldPos.x;
                const worldY = worldPos.y;
                const shepherd = this.game.shepherd;

                if (this.game.isDogCommandMode) {
                    const dog = this.game.dogToCommand;
                    if (dog) {
                        dog.command = 'move_to';
                        dog.moveTarget = { x: worldX, y: worldY };
                        this.game.logMessage(`${dog.name}ì´(ê°€) ì§€ì •ëœ ìœ„ì¹˜ë¡œ ì´ë™í•©ë‹ˆë‹¤.`);
                        this.game.dogMoveMarkers.push({ x: worldX, y: worldY, dogId: dog.id, timer: 120 });
                    }
                    this.game.isDogCommandMode = false;
                    this.game.dogToCommand = null;
                    this.game.canvas.style.cursor = 'pointer';
                    return;
                }

                if (this.game.isBuildMode) {
                    const gridX = Math.floor(worldX / config.FENCE_SIZE);
                    const gridY = Math.floor(worldY / config.FENCE_SIZE);
                    const fenceKey = `${gridX},${gridY}`;
                    const fenceWorldX = gridX * config.FENCE_SIZE + config.FENCE_SIZE / 2;
                    const fenceWorldY = gridY * config.FENCE_SIZE + config.FENCE_SIZE / 2;
                    const distToFence = utils.distance(shepherd, { x: fenceWorldX, y: fenceWorldY });

                    if (distToFence > 100) {
                        this.game.logMessage("ë„ˆë¬´ ë©€ì–´ì„œ ìš¸íƒ€ë¦¬ë¥¼ ì§€ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                        return;
                    }

                    if (this.game.world.fences.has(fenceKey)) {
                        this.game.world.fences.delete(fenceKey);
                        this.game.gameState.fences++;
                        this.game.logMessage("ìš¸íƒ€ë¦¬ë¥¼ ì² ê±°í•˜ì—¬ íšŒìˆ˜í–ˆìŠµë‹ˆë‹¤.");
                    } else {
                        if (this.game.gameState.fences > 0) {
                            if (this.game.canPlaceFence(gridX, gridY)) {
                                this.game.world.fences.add(fenceKey);
                                this.game.gameState.fences--;
                                if (this.game.gameState.fences <= 0) {
                                    this.game.isBuildMode = false;
                                    this.game.logMessage("ìš¸íƒ€ë¦¬ë¥¼ ëª¨ë‘ ì†Œì§„í•˜ì—¬ ê±´ì„¤ ëª¨ë“œë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.");
                                }
                            } else {
                                this.game.logMessage("ì´ê³³ì—ëŠ” ìš¸íƒ€ë¦¬ë¥¼ ì„¤ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                            }
                        } else {
                             this.game.logMessage("ë³´ìœ í•œ ìš¸íƒ€ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.");
                        }
                    }
                    return;
                }

                if (this.game.isCutMode) {
                    const gridX = Math.floor(worldX / config.GRASS_TILE_SIZE);
                    const gridY = Math.floor(worldY / config.GRASS_TILE_SIZE);
                    const grassWorldX = gridX * config.GRASS_TILE_SIZE + config.GRASS_TILE_SIZE / 2;
                    const grassWorldY = gridY * config.GRASS_TILE_SIZE + config.GRASS_TILE_SIZE / 2;
                    const distToGrass = utils.distance(shepherd, { x: grassWorldX, y: grassWorldY });

                    if (distToGrass > 80) {
                        this.game.logMessage("ë„ˆë¬´ ë©€ì–´ì„œ í’€ì„ ë²¨ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                        return;
                    }

                    const tileInfo = this.game.getGrassTileAt(gridX, gridY);

                    if (tileInfo) {
                        if (tileInfo.tile.richness === tileInfo.tile.maxRichness) {
                            tileInfo.tile.richness = 0;
                            tileInfo.tile.regrowthTimer = 10;
                            this.game.gameState.hayStock++;
                            this.game.logMessage("í’€ì„ ë² ì–´ ê±´ì´ˆ 1ê°œë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤.");
                        } else {
                            this.game.logMessage("ì™„ì „íˆ ìë€ í’€ë§Œ ë²¨ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
                        }
                    }
                    return;
                }

                if (this.game.gameState.paused) return;

                for (const entity of this.game.entities) {
                    if (entity instanceof Sheep && utils.distance({x: worldX, y: worldY}, entity) < entity.radius) {
                        if (this.game.shepherd.draggedSheep.includes(entity)) {
                            this.game.ui.toggleSheepInfoModal(true, entity);
                        } else {
                            const distToShepherd = utils.distance(this.game.shepherd, entity);
                            if (distToShepherd < 50) {
                                this.game.shepherd.toggleDragSheep(entity);
                            } else {
                                this.game.ui.toggleSheepInfoModal(true, entity);
                            }
                        }
                        return;
                    }
                    if (entity instanceof Dog && utils.distance({x: worldX, y: worldY}, entity) < entity.radius) {
                        this.game.ui.toggleDogInfoModal(true, entity);
                        return;
                    }
                }
            }
        }
        
        class UI {
            constructor(game) {
                this._dogStatusSnapshot = '';
                this.game = game;
                this.timeDisplay = document.getElementById('time-display'); 
                this.dayDisplay = document.getElementById('day-display');
                this.seasonDisplay = document.getElementById('season-display');
                this.seasonHud = document.getElementById('season-hud');
                this.goldDisplay = document.getElementById('gold-display'); 
                this.sheepDisplay = document.getElementById('sheep-display');
                this.hayDisplay = document.getElementById('hay-display'); 
                this.foodDisplay = document.getElementById('food-display');
                this.wolfSkinDisplay = document.getElementById('wolf-skin-display');
                this.woolDisplay = document.getElementById('wool-display');
                this.fenceDisplay = document.getElementById('fence-display');
                this.gateButton = document.getElementById('gate-button');
                this.marketButton = document.getElementById('market-button'); 
                this.hayActionButton = document.getElementById('hay-action-button');
                this.dogCommandAllButton = document.getElementById('dog-command-all-button'); 
                this.dogStatusUI = document.getElementById('dog-status-ui');
                this.feedShepherdButton = document.getElementById('feed-shepherd-button');
                this.buildFenceButton = document.getElementById('build-fence-button');
                this.cutGrassButton = document.getElementById('cut-grass-button');
                this.buildModeIndicator = document.getElementById('build-mode-indicator');
                this.cutModeIndicator = document.getElementById('cut-mode-indicator');
                this.manualOpenButton = document.getElementById('manual-open-button');
                this.manualModal = document.getElementById('manual-modal');
                this.closeManualButton = document.getElementById('close-manual-button');
                this.merchantHud = document.getElementById('merchant-hud');
                this.merchantDisplay = document.getElementById('merchant-display');
                this.cheonlajimangButton = document.getElementById('cheonlajimang-button');

                this.confirmModal = document.getElementById('confirm-modal');
                this.confirmMessage = document.getElementById('confirm-message');
                this.confirmYesButton = document.getElementById('confirm-yes-button');
                this.confirmNoButton = document.getElementById('confirm-no-button');
                
                // NEW: Cheonlajimang button listener
                this.cheonlajimangButton.addEventListener('click', () => {
                    if (this.game.shepherd.skillCooldown > 0) {
                        this.game.logMessage(`ì²œë¼ì§€ë§ì„ ì•„ì§ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (${Math.ceil(this.game.shepherd.skillCooldown / 60)}ì´ˆ)`);
                        return;
                    }
                    // Toggle skill mode and other modes off
                    this.game.isSkillMode = !this.game.isSkillMode;
                    this.game.isBuildMode = false;
                    this.game.isCutMode = false;
                    this.game.logMessage(`ì²œë¼ì§€ë§ ëª¨ë“œ ${this.game.isSkillMode ? 'í™œì„±' : 'ë¹„í™œì„±'}`);
                    this.game.canvas.style.cursor = this.game.isSkillMode ? 'crosshair' : 'pointer';
                    if (!this.game.isSkillMode) {
                        this.game.skillPath = []; // Clear path if deactivated manually
                    }
                });

                this.feedShepherdButton.addEventListener('click', () => {
                    this.toggleConfirmModal(true, 'ì‹ì‚¬ë¥¼ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?', () => {
                        this.game.shepherd.feed();
                    });
                });

                this.gateButton.addEventListener('click', () => {
                    const distToGate = utils.distance(this.game.shepherd, {x: this.game.world.pasture.gate.x + 40, y: this.game.world.pasture.gate.y + 10});
                    if (distToGate < 100) {
                        if (this.game.gameState.isNight && this.game.world.pasture.gate.isOpen) {
                            this.toggleConfirmModal(true, 'ë°¤ì´ ê¹Šì—ˆìŠµë‹ˆë‹¤. ì•„ì¹¨ìœ¼ë¡œ ì‹œê°„ì„ ë„˜ê¸°ì‹œê² ìŠµë‹ˆê¹Œ?', () => {
                                this.game.world.pasture.gate.isOpen = false; 
                                this.game.logMessage('ìš¸íƒ€ë¦¬ ë¬¸ì„ ë‹«ê³  ë°¤ì„ ë„˜ê²¼ìŠµë‹ˆë‹¤.');
                                
                                this.game.endOfDay();

                                const currentHourAtSkip = Math.floor(this.game.gameState.time / 60);
                                if (currentHourAtSkip >= 18) {
                                    this.game.gameState.day++;
                                }
                                this.game.gameState.time = 6 * 60;

                                this.game.startOfDay();
                                this.toggleConfirmModal(false);
                            }, () => {
                                this.game.world.pasture.gate.isOpen = false;
                                this.game.logMessage('ìš¸íƒ€ë¦¬ ë¬¸ì„ ë‹«ì•˜ìŠµë‹ˆë‹¤. ë°¤ì´ ê³„ì†ë©ë‹ˆë‹¤.');
                                this.toggleConfirmModal(false);
                            });
                        } else {
                            this.game.world.pasture.gate.isOpen = !this.game.world.pasture.gate.isOpen;
                            this.game.logMessage(`ìš¸íƒ€ë¦¬ ë¬¸ì„ ${this.game.world.pasture.gate.isOpen ? 'ì—´ì—ˆìŠµë‹ˆë‹¤' : 'ë‹«ì•˜ìŠµë‹ˆë‹¤'}.`);
                        }
                    }
                });

                this.buildFenceButton.addEventListener('click', () => {
                    this.game.isBuildMode = !this.game.isBuildMode;
                    if (this.game.isBuildMode) {
                        this.game.isCutMode = false;
                        this.game.isSkillMode = false;
                        if (this.game.gameState.fences > 0) {
                            this.game.logMessage("ìš¸íƒ€ë¦¬ ê±´ì„¤/ì² ê±° ëª¨ë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");
                        } else {
                            this.game.logMessage("ë³´ìœ í•œ ìš¸íƒ€ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤. ì² ê±°ëŠ” ê°€ëŠ¥í•©ë‹ˆë‹¤.");
                        }
                    } else {
                        this.game.logMessage("ìš¸íƒ€ë¦¬ ê±´ì„¤/ì² ê±° ëª¨ë“œë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.");
                    }
                    this.game.canvas.style.cursor = this.game.isBuildMode ? 'cell' : 'pointer';
                });

                this.cutGrassButton.addEventListener('click', () => {
                    this.game.isCutMode = !this.game.isCutMode;
                    if (this.game.isCutMode) {
                        this.game.isBuildMode = false;
                        this.game.isSkillMode = false;
                        this.game.logMessage("í’€ë² ê¸° ëª¨ë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");
                    } else {
                        this.game.logMessage("í’€ë² ê¸° ëª¨ë“œë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.");
                    }
                    this.game.canvas.style.cursor = this.game.isCutMode ? 'grab' : 'pointer';
                });

                this.marketButton.addEventListener('click', () => this.toggleMarketModal(true));
                this.hayActionButton.addEventListener('click', () => {
                    const distToHaystack = utils.distance(this.game.shepherd, this.game.world.pasture.haystack);
                    const distToTrough = utils.distance(this.game.shepherd, {x: this.game.world.pasture.trough.x + 50, y: this.game.world.pasture.trough.y + 10});
                    if (distToHaystack < 80) this.toggleHayModal(true, 'toTrough');
                    else if (distToTrough < 80) this.toggleHayModal(true, 'fromTrough');
                });
                this.dogCommandAllButton.addEventListener('click', () => {
                    const dogs = this.game.entities.filter(e => e instanceof Dog);
                    if (dogs.length > 0) { 
                        const newCommand = dogs[0].command === 'follow' ? 'stay' : 'follow'; 
                        dogs.forEach(d => d.command = newCommand); 
                        this.game.logMessage(`ëª¨ë“  ê°œì—ê²Œ '${newCommand === 'follow' ? 'ë”°ë¼ì™€' : 'ê¸°ë‹¤ë ¤'}' ëª…ë ¹ì„ ë‚´ë ¸ìŠµë‹ˆë‹¤.`);
                    }
                });
                
                this.dogStatusUI.addEventListener('click', (e) => {
                    const dogDiv = e.target.closest('.dog-status-item');
                    if (!dogDiv) return;
                    const dogId = Number(dogDiv.dataset.dogId);
                    const dog = this.game.entities.find(d => d instanceof Dog && d.id === dogId);
                    if (!dog) return;

                    if (dog.command === 'move_to') {
                        dog.command = 'follow';
                        dog.moveTarget = null;
                        this.game.logMessage(`${dog.name}ì˜ ì´ë™ ëª…ë ¹ì„ ì·¨ì†Œí•˜ê³  'ë”°ë¼ì™€'ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.`);
                    } else {
                        dog.command = dog.command === 'follow' ? 'stay' : 'follow';
                        const commandText = dog.command === 'follow' ? 'ë”°ë¼ì™€' : 'ê¸°ë‹¤ë ¤';
                        this.game.logMessage(`${dog.name}ì—ê²Œ '${commandText}' ëª…ë ¹ì„ ë‚´ë ¸ìŠµë‹ˆë‹¤.`);
                    }
                });
                
                this.manualOpenButton.addEventListener('click', () => this.toggleManualModal(true));
                this.closeManualButton.addEventListener('click', () => this.toggleManualModal(false));

                this.marketMessageDisplay = document.getElementById('market-message');
            }
            update() {
                const time = this.game.gameState.time; 
                const hour = Math.floor(time / 60) % 24; 
                const minute = Math.floor(time % 60);
                const period = hour < 12 ? 'ì˜¤ì „' : 'ì˜¤í›„'; 
                const displayHour = hour % 12 === 0 ? 12 : hour % 12;
                this.timeDisplay.textContent = `${period} ${String(displayHour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                this.dayDisplay.textContent = `Day ${this.game.gameState.day}`; 
                this.goldDisplay.textContent = this.game.gameState.gold;
                this.sheepDisplay.textContent = this.game.entities.filter(e => e instanceof Sheep && !e.isDead).length;
                this.hayDisplay.textContent = this.game.gameState.hayStock;
                this.foodDisplay.textContent = this.game.gameState.food;
                this.wolfSkinDisplay.textContent = this.game.gameState.wolfSkin;
                this.woolDisplay.textContent = this.game.gameState.wool;
                this.fenceDisplay.textContent = this.game.gameState.fences;

                const season = this.game.gameState.season;
                const seasonIcons = { Spring: 'ğŸŒ¸', Summer: 'â˜€ï¸', Autumn: 'ğŸ‚', Winter: 'â„ï¸' };
                const seasonNames = { Spring: 'ë´„', Summer: 'ì—¬ë¦„', Autumn: 'ê°€ì„', Winter: 'ê²¨ìš¸' };
                this.seasonHud.querySelector('span:first-child').textContent = seasonIcons[season];
                this.seasonDisplay.textContent = seasonNames[season];

                if (this.game.gameState.merchantState === 'present') {
                    this.merchantHud.classList.remove('hidden');
                    this.merchantDisplay.textContent = `ë– ë‚˜ê¸°ê¹Œì§€ ${this.game.gameState.merchantTimer}ì¼`;
                } else {
                    this.merchantHud.classList.remove('hidden');
                    this.merchantDisplay.textContent = `ì˜¤ê¸°ê¹Œì§€ ${this.game.gameState.merchantTimer}ì¼`;
                }

                const distToGate = utils.distance(this.game.shepherd, {x: this.game.world.pasture.gate.x + 40, y: this.game.world.pasture.gate.y + 10});
                this.gateButton.classList.toggle('hidden', !(distToGate < 100));
                this.gateButton.innerHTML = this.game.world.pasture.gate.isOpen ? 'ğŸšª ë¬¸ ë‹«ê¸°' : 'ğŸšª ë¬¸ ì—´ê¸°';
                
                const merchant = this.game.merchant;
                const canOpenMarket = merchant && !merchant.isDead && utils.distance(this.game.shepherd, merchant) < 100;
                this.marketButton.classList.toggle('hidden', !canOpenMarket);

                const inPasture = this.game.isInsidePasture(this.game.shepherd);
                const distToHaystack = utils.distance(this.game.shepherd, this.game.world.pasture.haystack);
                const distToTrough = utils.distance(this.game.shepherd, {x: this.game.world.pasture.trough.x + 50, y: this.game.world.pasture.trough.y + 10});
                const canAddToTrough = inPasture && distToHaystack < 80;
                const canTakeFromTrough = inPasture && distToTrough < 80;
                this.hayActionButton.classList.toggle('hidden', !(canAddToTrough || canTakeFromTrough));
                if (canAddToTrough) { this.hayActionButton.innerHTML = 'ğŸŒ¾ ê±´ì´ˆ ë„£ê¸°'; }
                else if (canTakeFromTrough) { this.hayActionButton.innerHTML = 'â†©ï¸ ê±´ì´ˆ ë˜ëŒë¦¬ê¸°'; }
                
                this.feedShepherdButton.classList.toggle('hidden', this.game.gameState.food <= 0);

                this.updateDogUI();
                
                // Update mode button styles
                this.buildFenceButton.classList.toggle('bg-blue-700', this.game.isBuildMode);
                this.cutGrassButton.classList.toggle('bg-green-700', this.game.isCutMode);
                this.cheonlajimangButton.classList.toggle('bg-purple-700', this.game.isSkillMode);

                this.buildModeIndicator.classList.toggle('hidden', !this.game.isBuildMode);
                this.cutModeIndicator.classList.toggle('hidden', !this.game.isCutMode);
                
                // NEW: Update skill button cooldown display
                const cooldown = this.game.shepherd.skillCooldown;
                if (cooldown > 0) {
                    this.cheonlajimangButton.disabled = true;
                    this.cheonlajimangButton.innerHTML = `ğŸ•¸ï¸ (${Math.ceil(cooldown / 60)}ì´ˆ)`;
                } else {
                    this.cheonlajimangButton.disabled = false;
                    this.cheonlajimangButton.innerHTML = 'ğŸ•¸ï¸ ì²œë¼ì§€ë§';
                }
            }

            showMessage(message, type = 'error') {
                this.marketMessageDisplay.textContent = message;
                this.marketMessageDisplay.classList.remove('hidden');
                this.marketMessageDisplay.classList.toggle('text-red-600', type === 'error');
                this.marketMessageDisplay.classList.toggle('text-green-600', type !== 'error');
                setTimeout(() => {
                    this.marketMessageDisplay.classList.add('hidden');
                }, 3000);
            }

            updateDogUI() {
                const dogs = this.game.entities.filter(e => e instanceof Dog && !e.isDead).sort((a, b) => a.id - b.id);
                
                this.dogCommandAllButton.classList.toggle('hidden', dogs.length === 0);
                
                const currentDogInfo = dogs.map(d => `${d.id}:${d.command}:${d.stance}:${d.name}`).join('|');
                const newSnapshot = `${dogs.length}|${currentDogInfo}`;

                if (this._dogStatusSnapshot === newSnapshot) return;
                this._dogStatusSnapshot = newSnapshot;

                this.dogStatusUI.innerHTML = '';

                for (let i = 0; i < 3; i++) {
                    const dogDiv = document.createElement('div');
                    dogDiv.className = 'hud-item dog-status-item w-32 flex-none flex flex-col items-center justify-center'; 
                    
                    const dog = dogs[i];

                    if (dog) {
                        dogDiv.dataset.dogId = String(dog.id);
                        let commandText = '';
                        if (dog.command === 'follow') commandText = 'ë”°ë¼ì™€';
                        else if (dog.command === 'stay') commandText = 'ê¸°ë‹¤ë ¤';
                        else if (dog.command === 'move_to') commandText = 'ì´ë™ ì¤‘';

                        const stanceText = (dog.stance === 'Guard') ? 'ê²½ê³„' : 'í‰í™”';
                        const stanceColor = (dog.stance === 'Guard') ? 'text-red-300' : 'text-green-300';
                        dogDiv.innerHTML = `<span class="block text-center">ğŸ¶ ${dog.name}</span> <span class="block text-xs text-center">${commandText} / <span class="${stanceColor}">${stanceText}</span></span>`;
                        dogDiv.classList.add('cursor-pointer');
                    } else {
                        dogDiv.classList.remove('cursor-pointer');
                        dogDiv.style.opacity = '0.7';
                        dogDiv.innerHTML = `<span class="block text-center">ğŸ•</span> <span class="block text-xs text-center">ì…ì–‘ í•„ìš”</span>`;
                    }
                    this.dogStatusUI.appendChild(dogDiv);
                }
            }
            toggleMarketModal(show) {
                document.getElementById('market-modal').classList.toggle('hidden', !show);
                this.game.gameState.paused = show;
                if (show) this.setupMarketModal();
            }
            setupMarketModal() {
                const buySection = document.getElementById('market-buy-section');
                const sellSection = document.getElementById('market-sell-section');
                
                buySection.innerHTML = `<h3 class="font-bold mb-2 text-lg">êµ¬ë§¤</h3><div id="gold-info-buy" class="text-sm mb-2">í˜„ì¬ ê³¨ë“œ: ${this.game.gameState.gold}</div>`;
                sellSection.innerHTML = `<h3 class="font-bold mb-2 text-lg">íŒë§¤</h3><div id="gold-info-sell" class="text-sm mb-2">í˜„ì¬ ê³¨ë“œ: ${this.game.gameState.gold}</div>`;

                const createItemHTML = (name, price, current, action) => {
                    const itemId = `${action}-${name.replace(/ /g, '_')}`;
                    let maxQty = 0;
                    if (action === 'buy') {
                        if (name === 'ìƒˆë¼ ì–‘') maxQty = Math.floor(this.game.gameState.gold / 5);
                        else if (name === 'ì–´ë¥¸ ì–‘') maxQty = Math.floor(this.game.gameState.gold / 10);
                        else if (name === 'ê°œ') {
                            const currentDogCount = this.game.entities.filter(e => e instanceof Dog && !e.isDead).length;
                            maxQty = Math.min(Math.floor(this.game.gameState.gold / 50), 3 - currentDogCount);
                        }
                        else if (name === 'ê±´ì´ˆ') maxQty = Math.floor(this.game.gameState.gold / 1);
                        else if (name === 'ì‹ëŸ‰') maxQty = Math.floor(this.game.gameState.gold / 1);
                        else if (name === 'ìš¸íƒ€ë¦¬') maxQty = Math.floor(this.game.gameState.gold / 1);
                        maxQty = Math.max(0, maxQty);
                    } else {
                        const merchant = this.game.merchant;
                        if (merchant) {
                            if (name === 'ìƒˆë¼ ì–‘') maxQty = this.game.entities.filter(e => e instanceof Sheep && !e.isDead && !e.isAdult && utils.distance(e, merchant) < 100).length;
                            else if (name === 'ì–´ë¥¸ ì–‘') maxQty = this.game.entities.filter(e => e instanceof Sheep && !e.isDead && e.isAdult && utils.distance(e, merchant) < 100).length;
                        }
                        if (name === 'ëŠ‘ëŒ€ ê°€ì£½') maxQty = this.game.gameState.wolfSkin;
                        else if (name === 'ì–‘í„¸') maxQty = this.game.gameState.wool;
                    }

                    const isDisabled = maxQty === 0 ? 'disabled' : '';
                    const initialSliderValue = maxQty === 0 ? 0 : 1;
                    
                    return `
                        <div class="bg-gray-100 p-3 rounded-md">
                            <p class="font-semibold">${name} <span class="text-sm font-normal">(${price} ê³¨ë“œ)</span></p>
                            <p class="text-sm text-gray-600">ë³´ìœ : ${current}</p>
                            <div class="flex items-center gap-2 mt-2">
                                <span class="text-lg w-8 text-center" id="${itemId}-display">${initialSliderValue}</span>
                                <input id="${itemId}-qty" type="range" value="${initialSliderValue}" min="0" max="${maxQty}" class="flex-1" oninput="document.getElementById('${itemId}-display').textContent=this.value" ${isDisabled}>
                                <button onclick="game.market.${action}('${name.replace(/ /g, '_')}')" class="bg-blue-500 text-white p-1 rounded-md text-sm ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}" ${isDisabled}>${action === 'buy' ? 'êµ¬ë§¤' : 'íŒë§¤'}</button>
                            </div>
                        </div>`;
                };

                const youngSheepCount = this.game.entities.filter(e=>e instanceof Sheep && !e.isDead && !e.isAdult).length;
                const adultSheepCount = this.game.entities.filter(e=>e instanceof Sheep && !e.isDead && e.isAdult).length;
                const dogCount = this.game.entities.filter(e=>e instanceof Dog && !e.isDead).length;
                const hayStockCount = this.game.gameState.hayStock;
                const foodCount = this.game.gameState.food;
                const wolfSkinCount = this.game.gameState.wolfSkin;
                const woolCount = this.game.gameState.wool;
                const fenceCount = this.game.gameState.fences;

                buySection.innerHTML += createItemHTML('ìƒˆë¼ ì–‘', 5, youngSheepCount, 'buy');
                buySection.innerHTML += createItemHTML('ì–´ë¥¸ ì–‘', 10, adultSheepCount, 'buy');
                buySection.innerHTML += createItemHTML('ê°œ', 50, dogCount, 'buy');
                buySection.innerHTML += createItemHTML('ê±´ì´ˆ', 1, hayStockCount, 'buy');
                buySection.innerHTML += createItemHTML('ì‹ëŸ‰', 1, foodCount, 'buy');
                buySection.innerHTML += createItemHTML('ìš¸íƒ€ë¦¬', 1, fenceCount, 'buy');
                
                const sellableYoungSheep = this.game.entities.filter(e=>e instanceof Sheep && !e.isDead && !e.isAdult).length;
                const sellableAdultSheep = this.game.entities.filter(e=>e instanceof Sheep && !e.isDead && e.isAdult).length;

                sellSection.innerHTML += createItemHTML('ìƒˆë¼ ì–‘', 2, sellableYoungSheep, 'sell');
                sellSection.innerHTML += createItemHTML('ì–´ë¥¸ ì–‘', 5, sellableAdultSheep, 'sell');
                sellSection.innerHTML += createItemHTML('ëŠ‘ëŒ€ ê°€ì£½', 1, wolfSkinCount, 'sell');
                sellSection.innerHTML += createItemHTML('ì–‘í„¸', 1, woolCount, 'sell');
            }
            toggleHayModal(show, direction = 'toTrough') {
                document.getElementById('hay-modal').classList.toggle('hidden', !show);
                this.game.gameState.paused = show;
                if (show) this.setupHayModal(direction);
            }
            setupHayModal(direction) {
                const title = document.getElementById('hay-modal-title');
                const info = document.getElementById('hay-modal-info');
                const input = document.getElementById('hay-quantity-input');
                const slider = document.getElementById('hay-quantity-slider');
                const confirmBtn = document.getElementById('hay-confirm-button');
                const minusBtn = document.getElementById('hay-quantity-minus');
                const plusBtn = document.getElementById('hay-quantity-plus');
                const trough = this.game.world.pasture.trough;
                
                const totalTroughHay = this.game.calculateTroughHayAmount();
                const totalTroughMaxHay = this.game.calculateTroughMaxHay();
                
                let max = 0;
                if (direction === 'toTrough') {
                    title.textContent = "ì°½ê³  â†’ ë¨¹ì´í†µ";
                    max = Math.floor(Math.min(this.game.gameState.hayStock, totalTroughMaxHay - totalTroughHay));
                    info.textContent = `ì°½ê³  ë³´ìœ ëŸ‰: ${this.game.gameState.hayStock}, ë¨¹ì´í†µ ì—¬ìœ : ${Math.floor(totalTroughMaxHay - totalTroughHay)}`;
                } else {
                    title.textContent = "ë¨¹ì´í†µ â†’ ì°½ê³ ";
                    max = Math.floor(totalTroughHay);
                    info.textContent = `ë¨¹ì´í†µ ë³´ìœ ëŸ‰: ${Math.floor(totalTroughHay)}`;
                }
                input.max = max; slider.max = max;
                input.value = max > 0 ? 1 : 0; slider.value = max > 0 ? 1 : 0;
                const syncValues = (source) => {
                    const value = Math.max(1, Math.min(max, parseInt(source.value)));
                    input.value = value; slider.value = value;
                };
                input.oninput = () => syncValues(input);
                slider.oninput = () => syncValues(slider);
                minusBtn.onclick = () => { input.value = Math.max(1, parseInt(input.value) - 1); syncValues(input); };
                plusBtn.onclick = () => { input.value = Math.min(max, parseInt(input.value) + 1); syncValues(input); };
                confirmBtn.onclick = () => {
                    const quantity = parseInt(input.value);
                    if (quantity > 0 && quantity <= max) this.game.transferHay(direction, quantity);
                    this.toggleHayModal(false);
                };
            }
            toggleSheepInfoModal(show, sheep = null) {
                const modal = document.getElementById('sheep-info-modal');
                modal.classList.toggle('hidden', !show);
                this.game.gameState.paused = show;

                if (show && sheep) {
                    const input = document.getElementById('sheep-name-input');
                    const statusInfo = document.getElementById('sheep-status-info');
                    const confirmBtn = document.getElementById('sheep-info-confirm');
                    const slaughterBtn = document.getElementById('sheep-slaughter-button');
                    const shearBtn = document.getElementById('sheep-shear-button');
                    const sellBtn = document.getElementById('sheep-sell-button');
                    const releaseBtn = document.getElementById('sheep-release-button');
                    
                    input.value = sheep.name;
                    
                    if (sheep.isAdult) {
                        statusInfo.textContent = sheep.breedingCooldown > 0 ? `ìƒì‹ê¹Œì§€ ${sheep.breedingCooldown}ì¼ ë‚¨ìŒ` : 'ë²ˆì‹ ê°€ëŠ¥';
                    } else {
                        statusInfo.textContent = `ì„±ì¥ê¹Œì§€ ${7 - sheep.age}ì¼ ë‚¨ìŒ`;
                    }

                    input.focus();
                    confirmBtn.onclick = () => {
                        if (input.value) sheep.name = input.value.substring(0, 15);
                        this.toggleSheepInfoModal(false);
                    };

                    if (this.game.shepherd.draggedSheep.includes(sheep)) {
                        releaseBtn.classList.remove('hidden');
                        releaseBtn.onclick = () => {
                            this.game.shepherd.toggleDragSheep(sheep);
                            this.toggleSheepInfoModal(false);
                        };
                    } else {
                        releaseBtn.classList.add('hidden');
                    }
                    
                    const isDragged = this.game.shepherd.draggedSheep.includes(sheep);

                    if (sheep.isAdult) {
                        shearBtn.classList.remove('hidden');
                        if (!isDragged || sheep.shearCooldown > 0) {
                            shearBtn.disabled = true;
                            if (!isDragged) {
                                shearBtn.textContent = 'ëŒê³ ì™€ì•¼ ê¹ê¸° ê°€ëŠ¥';
                            } else {
                                shearBtn.textContent = `í„¸ ìë¼ëŠ” ì¤‘ (${sheep.shearCooldown}ì¼)`;
                            }
                        } else {
                            shearBtn.disabled = false;
                            shearBtn.textContent = 'í„¸ ê¹ê¸°';
                        }
                    } else {
                        shearBtn.classList.add('hidden');
                    }

                    if (!isDragged) {
                        slaughterBtn.disabled = true;
                        slaughterBtn.textContent = 'ëŒê³ ì™€ì•¼ ë„ì¶• ê°€ëŠ¥';
                    } else {
                        slaughterBtn.disabled = false;
                        slaughterBtn.textContent = 'ë„ì¶•';
                    }

                    shearBtn.onclick = () => {
                        const isCurrentlyDragged = this.game.shepherd.draggedSheep.includes(sheep);
                        if (sheep.isAdult && sheep.shearCooldown === 0 && isCurrentlyDragged) {
                            this.game.gameState.wool++;
                            sheep.shearCooldown = 5;
                            sheep.isSheared = true;
                            this.game.logMessage(`${sheep.name}ì˜ í„¸ì„ ê¹ì•„ ì–‘í„¸ 1ê°œë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤.`);
                            this.toggleSheepInfoModal(false);
                        }
                    };
                    
                    slaughterBtn.onclick = () => {
                        const isCurrentlyDragged = this.game.shepherd.draggedSheep.includes(sheep);
                        if (!isCurrentlyDragged) return;

                        const foodGained = sheep.isAdult ? 3 : 1;
                        const message = `${sheep.name}ì„(ë¥¼) ë„ì¶•í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì‹ëŸ‰ ${foodGained} íšë“)`;
                        
                        this.toggleConfirmModal(true, message, () => {
                            this.game.gameState.food += foodGained;
                            sheep.isDead = true;
                            const index = this.game.shepherd.draggedSheep.indexOf(sheep);
                            if (index > -1) {
                                this.game.shepherd.draggedSheep.splice(index, 1);
                            }
                            this.game.logMessage(`${sheep.name}ì„(ë¥¼) ë„ì¶•í•˜ì—¬ ì‹ëŸ‰ ${foodGained}ì„(ë¥¼) ì–»ì—ˆìŠµë‹ˆë‹¤.`);
                            this.toggleSheepInfoModal(false);
                        });
                    };

                    const merchant = this.game.merchant;
                    const canSell = merchant && !merchant.isDead && utils.distance(sheep, merchant) < 100 && utils.distance(this.game.shepherd, merchant) < 100;

                    if (canSell) {
                        sellBtn.disabled = false;
                        sellBtn.textContent = 'íŒë§¤';
                        sellBtn.classList.remove('bg-gray-500', 'cursor-not-allowed');
                        sellBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                        sellBtn.title = 'ì–‘ì„ ì‹œì¥ì— íŒë§¤í•©ë‹ˆë‹¤.';
                    } else {
                        sellBtn.disabled = true;
                        sellBtn.textContent = 'íŒë§¤ ë¶ˆê°€';
                        sellBtn.classList.add('bg-gray-500', 'cursor-not-allowed');
                        sellBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                        sellBtn.title = 'ìƒì¸ì—ê²Œ ì–‘ê³¼ í•¨ê»˜ ê°€ê¹Œì´ ê°€ì•¼ íŒë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
                    }

                    sellBtn.onclick = () => {
                        if (!canSell) return;
                        const price = sheep.isAdult ? 5 : 2;
                        const message = `${sheep.name}ì„(ë¥¼) ${price}ê³¨ë“œì— íŒë§¤í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;

                        this.toggleConfirmModal(true, message, () => {
                            this.game.gameState.gold += price;
                            sheep.isDead = true;
                            const index = this.game.shepherd.draggedSheep.indexOf(sheep);
                            if (index > -1) {
                                this.game.shepherd.draggedSheep.splice(index, 1);
                            }
                            this.game.logMessage(`${sheep.name}ì„(ë¥¼) ${price}ê³¨ë“œì— íŒë§¤í–ˆìŠµë‹ˆë‹¤.`);
                            this.toggleSheepInfoModal(false);
                        });
                    };
                }
            }
            toggleDogInfoModal(show, dog = null) {
                const modal = document.getElementById('dog-info-modal');
                modal.classList.toggle('hidden', !show);
                this.game.gameState.paused = show;

                if (show && dog) {
                    const nameInput = document.getElementById('dog-name-input');
                    const hungerInfo = document.getElementById('dog-hunger-info');
                    const feedButton = document.getElementById('dog-feed-button');
                    const moveButton = document.getElementById('dog-move-button');
                    const confirmBtn = document.getElementById('dog-info-confirm');
                    const guardBtn = document.getElementById('dog-stance-guard');
                    const peaceBtn = document.getElementById('dog-stance-peace');
                    
                    nameInput.value = dog.name;
                    hungerInfo.textContent = `${Math.ceil(dog.hunger)} / ${dog.maxHunger}`;
                    
                    const updateStanceButtons = () => {
                        if (dog.stance === 'Guard') {
                            guardBtn.classList.add('bg-red-500', 'text-white');
                            guardBtn.classList.remove('bg-gray-200');
                            peaceBtn.classList.add('bg-gray-200');
                            peaceBtn.classList.remove('bg-green-500', 'text-white');
                        } else {
                            peaceBtn.classList.add('bg-green-500', 'text-white');
                            peaceBtn.classList.remove('bg-gray-200');
                            guardBtn.classList.add('bg-gray-200');
                            guardBtn.classList.remove('bg-red-500', 'text-white');
                        }
                    };

                    updateStanceButtons();

                    guardBtn.onclick = () => {
                        dog.stance = 'Guard';
                        this.game.logMessage(`${dog.name}ì˜ íƒœì„¸ë¥¼ 'ê²½ê³„'ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.`);
                        updateStanceButtons();
                    };

                    peaceBtn.onclick = () => {
                        dog.stance = 'Peace';
                        this.game.logMessage(`${dog.name}ì˜ íƒœì„¸ë¥¼ 'í‰í™”'ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.`);
                        updateStanceButtons();
                    };

                    moveButton.style.display = dog.command === 'stay' ? 'block' : 'none';
                    moveButton.onclick = () => {
                        this.game.enterDogCommandMode(dog);
                    };

                    feedButton.onclick = () => {
                        dog.feed();
                        hungerInfo.textContent = `${Math.ceil(dog.hunger)} / ${dog.maxHunger}`;
                        if (this.game.gameState.food <= 0) {
                            feedButton.disabled = true;
                        }
                    };
                    feedButton.disabled = this.game.gameState.food <= 0;
                    
                    confirmBtn.onclick = () => {
                        if (nameInput.value) dog.name = nameInput.value.substring(0, 15);
                        this.toggleDogInfoModal(false);
                    };
                }
            }
            showGameOverModal() {
                document.getElementById('game-over-modal').classList.remove('hidden');
                document.getElementById('game-over-stats').textContent = `ìƒì¡´ ì¼ì: ${this.game.gameState.day}ì¼, ë³´ìœ  ê³¨ë“œ: ${this.game.gameState.gold}`;
            }

            getFormattedTime() {
                const time = this.game.gameState.time;
                const hour = Math.floor(time / 60) % 24;
                const minute = Math.floor(time % 60);
                const period = hour < 12 ? 'ì˜¤ì „' : 'ì˜¤í›„';
                const displayHour = hour % 12 === 0 ? 12 : hour % 12;
                return `${period} ${String(displayHour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
            }

            toggleConfirmModal(show, message = '', onConfirm = () => {}, onCancel = () => {}) {
                this.confirmModal.classList.toggle('hidden', !show);
                this.game.gameState.paused = show;

                if (show) {
                    this.confirmMessage.textContent = message;
                    this.confirmYesButton.onclick = () => { onConfirm(); this.toggleConfirmModal(false); };
                    this.confirmNoButton.onclick = () => { onCancel(); this.toggleConfirmModal(false); };
                }
            }
            
            toggleManualModal(show) {
                this.manualModal.classList.toggle('hidden', !show);
                this.game.gameState.paused = show;
            }
        }
        
        class Market {
            constructor(game) { this.game = game; }
            buy(item) {
                const qtyInput = document.getElementById(`buy-${item}-qty`);
                const qty = parseInt(qtyInput.value);
                if (isNaN(qty) || qty <= 0) {
                    this.game.ui.showMessage("êµ¬ë§¤ ìˆ˜ëŸ‰ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", 'error');
                    return;
                }
                const costs = { 'ìƒˆë¼_ì–‘': 5, 'ì–´ë¥¸_ì–‘': 10, 'ê°œ': 50, 'ê±´ì´ˆ': 1, 'ì‹ëŸ‰': 1, 'ìš¸íƒ€ë¦¬': 1 };
                const totalCost = costs[item] * qty;
                if (this.game.gameState.gold >= totalCost) {
                    if (item === 'ê°œ' && this.game.entities.filter(e => e instanceof Dog && !e.isDead).length + qty > 3) { 
                        this.game.ui.showMessage("ê°œëŠ” ìµœëŒ€ 3ë§ˆë¦¬ê¹Œì§€ ë³´ìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.", 'error'); 
                        return; 
                    }
                    this.game.gameState.gold -= totalCost;
                    const pos = {x: this.game.shepherd.x, y: this.game.shepherd.y};
                    for(let i=0; i<qty; i++) {
                        if (item === 'ìƒˆë¼_ì–‘') this.game.entities.push(new Sheep(this.game, pos.x, pos.y, false));
                        else if (item === 'ì–´ë¥¸_ì–‘') this.game.entities.push(new Sheep(this.game, pos.x, pos.y, true));
                        else if (item === 'ê°œ') this.game.entities.push(new Dog(this.game, pos.x, pos.y));
                        else if (item === 'ê±´ì´ˆ') this.game.gameState.hayStock++;
                        else if (item === 'ì‹ëŸ‰') this.game.gameState.food++;
                        else if (item === 'ìš¸íƒ€ë¦¬') this.game.gameState.fences++;
                    }
                    this.game.ui.showMessage(`${qty} ${item.replace('_', ' ')} êµ¬ë§¤ ì™„ë£Œ!`, 'success');
                    this.game.logMessage(`${qty} ${item.replace('_', ' ')}ì„(ë¥¼) êµ¬ë§¤í–ˆìŠµë‹ˆë‹¤. (ë‚¨ì€ ê³¨ë“œ: ${this.game.gameState.gold})`);
                    this.game.ui.setupMarketModal();
                } else { 
                    this.game.ui.showMessage("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.", 'error'); 
                }
            }
            sell(item) {
                const qtyInput = document.getElementById(`sell-${item}-qty`);
                const qty = parseInt(qtyInput.value);
                if (isNaN(qty) || qty <= 0) {
                    this.game.ui.showMessage("íŒë§¤ ìˆ˜ëŸ‰ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", 'error');
                    return;
                }
                const prices = { 'ìƒˆë¼_ì–‘': 2, 'ì–´ë¥¸_ì–‘': 5, 'ëŠ‘ëŒ€_ê°€ì£½': 1, 'ì–‘í„¸': 1 };
                
                if (item === 'ìƒˆë¼_ì–‘' || item === 'ì–´ë¥¸_ì–‘') {
                    const isAdult = item === 'ì–´ë¥¸_ì–‘';
                    const merchant = this.game.merchant;
                    if (!merchant) {
                        this.game.ui.showMessage(`ìƒì¸ì´ ì—†ì–´ íŒë§¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'error'); 
                        return;
                    }

                    const sheepToSell = this.game.entities.filter(e => e instanceof Sheep && !e.isDead && e.isAdult === isAdult && utils.distance(e, merchant) < 100);
                    if (sheepToSell.length >= qty) {
                        for(let i=0; i<qty; i++) {
                            const soldSheep = sheepToSell[i];
                            soldSheep.isDead = true;
                            this.game.logMessage(`${soldSheep.name}ì´(ê°€) ì‹œì¥ì— íŒë§¤ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                            soldSheep.deathLogged = true;
                            
                            const index = this.game.shepherd.draggedSheep.indexOf(soldSheep);
                            if (index > -1) {
                                this.game.shepherd.draggedSheep.splice(index, 1);
                            }
                        }
                        this.game.gameState.gold += prices[item] * qty;
                        this.game.ui.showMessage(`${qty} ${item.replace('_', ' ')} íŒë§¤ ì™„ë£Œ!`, 'success');
                        this.game.logMessage(`${qty} ${item.replace('_', ' ')}ì„(ë¥¼) íŒë§¤í–ˆìŠµë‹ˆë‹¤. (ì´ ê³¨ë“œ: ${this.game.gameState.gold})`);
                        this.game.ui.setupMarketModal();
                    } else { 
                        this.game.ui.showMessage(`ìƒì¸ ê·¼ì²˜ì— íŒë§¤í•  ${isAdult ? 'ì–´ë¥¸ ì–‘' : 'ìƒˆë¼ ì–‘'}ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.`, 'error'); 
                    }
                } else if (item === 'ëŠ‘ëŒ€_ê°€ì£½') {
                    if (this.game.gameState.wolfSkin >= qty) {
                        this.game.gameState.wolfSkin -= qty;
                        this.game.gameState.gold += prices[item] * qty;
                        this.game.ui.showMessage(`${qty} ëŠ‘ëŒ€ ê°€ì£½ íŒë§¤ ì™„ë£Œ!`, 'success');
                        this.game.logMessage(`${qty} ëŠ‘ëŒ€ ê°€ì£½ì„ íŒë§¤í–ˆìŠµë‹ˆë‹¤. (ì´ ê³¨ë“œ: ${this.game.gameState.gold})`);
                        this.game.ui.setupMarketModal();
                    } else {
                        this.game.ui.showMessage("ë³´ìœ í•œ ëŠ‘ëŒ€ ê°€ì£½ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.", 'error');
                    }
                } else if (item === 'ì–‘í„¸') {
                    if (this.game.gameState.wool >= qty) {
                        this.game.gameState.wool -= qty;
                        this.game.gameState.gold += prices[item] * qty;
                        this.game.ui.showMessage(`${qty} ì–‘í„¸ íŒë§¤ ì™„ë£Œ!`, 'success');
                        this.game.logMessage(`${qty} ì–‘í„¸ì„ íŒë§¤í–ˆìŠµë‹ˆë‹¤. (ì´ ê³¨ë“œ: ${this.game.gameState.gold})`);
                        this.game.ui.setupMarketModal();
                    } else {
                        this.game.ui.showMessage("ë³´ìœ í•œ ì–‘í„¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.", 'error');
                    }
                }
            }
        }

        // --- Podo Studio Logo ---
        function drawGrapeLogo() {
            const logoContainer = document.getElementById('logo-container');
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("viewBox", "0 0 100 100");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");

            const grapeColor = "#6d28d9";
            const stemColor = "#22c55e";
            const grapeRadius = 13;

            const grapePositions = [
                { cx: 30, cy: 40, hasBorder: false }, { cx: 70, cy: 40, hasBorder: false }, { cx: 50, cy: 84, hasBorder: false },
                { cx: 60, cy: 62, hasBorder: true }, { cx: 40, cy: 62, hasBorder: true }, { cx: 50, cy: 40, hasBorder: true },
            ];

            grapePositions.forEach(pos => {
                const circle = document.createElementNS(svgNS, "circle");
                circle.setAttribute("cx", pos.cx);
                circle.setAttribute("cy", pos.cy);
                circle.setAttribute("r", grapeRadius);
                circle.setAttribute("fill", grapeColor);
                if (pos.hasBorder) {
                    circle.setAttribute("stroke", "white");
                    circle.setAttribute("stroke-width", "2.5");
                }
                svg.appendChild(circle);
            });

            const stem = document.createElementNS(svgNS, "line");
            stem.setAttribute("x1", "50");
            stem.setAttribute("y1", "27");
            stem.setAttribute("x2", "50");
            stem.setAttribute("y2", "20");
            stem.setAttribute("stroke", stemColor);
            stem.setAttribute("stroke-width", "5");
            stem.setAttribute("stroke-linecap", "round");
            svg.appendChild(stem);

            logoContainer.innerHTML = '';
            logoContainer.appendChild(svg);
        }

        // --- ê²Œì„ ì´ˆê¸°í™” ë° ì‹¤í–‰ ---
        const canvas = document.getElementById('gameCanvas');
        let game = null;
        
        const introModal = document.getElementById('introModal');
        const startButton = document.getElementById('startButton');
        const gameContainer = document.getElementById('game-container');
        
        startButton.addEventListener('click', () => {
            introModal.style.display = 'none';
            gameContainer.style.display = 'block';
            document.body.style.backgroundColor = '#333';
            game = new Game(canvas);
            game.resizeCanvas();
            game.start();
        });
        
        drawGrapeLogo();

    </script>
</body>
</html>
